

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>API — Vue.js</title>
    <meta charset="utf-8">
    <meta name="description" content="Vue.js - Le Framework JavaScript Évolutif">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    <link rel="alternate" hreflang="x-default" href="https://vuejs.org/v2/api/index.html">
    <link rel="alternate" hreflang="zh" href="https://cn.vuejs.org/v2/api/index.html">
    <link rel="alternate" hreflang="ja" href="https://jp.vuejs.org/v2/api/index.html">
    <link rel="alternate" hreflang="ru" href="https://ru.vuejs.org/v2/api/index.html">
    <link rel="alternate" hreflang="ko" href="https://kr.vuejs.org/v2/api/index.html">
    <link rel="alternate" hreflang="pt-BR" href="https://br.vuejs.org/v2/api/index.html">
    <link rel="alternate" hreflang="fr" href="https://fr.vuejs.org/v2/api/index.html">

    <meta property="og:type" content="article">
    <meta property="og:title" content="API — Vue.js">
    <meta property="og:description" content="Vue.js - Le Framework JavaScript Évolutif">
    <meta property="og:image" content="https://vuejs.org//images/logo.png">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="API — Vue.js">
    <meta name="twitter:description" content="Vue.js - Le Framework JavaScript Évolutif">
    <meta name="twitter:image" content="https://vuejs.org/images/logo.png">

    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/images/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/images/icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/images/icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/icons/favicon-16x16.png">
    <meta name="msapplication-TileImage" content="/images/icons/ms-icon-144x144.png">
    <link rel="icon" href="/images/logo.png" type="image/png">

    <meta name="msapplication-TileColor" content="#4fc08d">
    <meta name="theme-color" content="#4fc08d">

    <meta name="msapplication-config" content="browserconfig.xml">
    <link rel="manifest" href="/manifest.json">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Dosis:500&text=Vue.js' rel='stylesheet' type='text/css'>

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    <link rel="stylesheet" href="/css/page.css">

    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="/js/vue.js"></script>
    <script>
      Vue.config.productionTip = false
      window.PAGE_TYPE = "api"
    </script>

    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-46852172-1', 'vuejs.org');
      ga('send', 'pageview');
    </script>

    <!-- vimeo analytics -->
    <script type="text/javascript" defer="defer" src="https://extend.vimeocdn.com/ga/72160148.js"></script>
  </head>
  <body class="docs">
    <div id="mobile-bar" >
      <a class="menu-button"></a>
      <a class="logo" href="/"></a>
    </div>
    <div id="header">
  <a id="logo" href="/">
    <img src="/images/logo.png" alt="vue logo">
    <span>Vue.js</span>
  </a>
  <ul id="nav">
    <li>
  <form id="search-form">
    <input type="text" id="search-query-nav" class="search-query st-default-search-input">
  </form>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link current">Doc</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Documentations</h4></li>
    <li>
      <ul>
        <li><a href="/v2/guide/" class="nav-link">Guide</a></li>
        <li><a href="/v2/api/" class="nav-link current">API</a></li>
        <li><a href="/v2/style-guide/" class="nav-link">Conventions</a></li>
        <li><a href="/v2/examples/" class="nav-link">Exemples</a></li>
        <li><a href="/v2/cookbook/" class="nav-link">Tutoriels</a></li>
      </ul>
    </li>
    <li><h4>Videos</h4></li>
    <li>
      <ul>
        <li><a href="https://www.vuemastery.com/courses/" class="nav-link" target="_blank">Vue Mastery (EN)</a></li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container ecosystem">
  <a class="nav-link">Écosystème</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Aide</h4></li>
    <li><ul>
      <li><a href="https://forum.vuejs.org/c/french" class="nav-link" target="_blank">Forum</a></li>
      <li><a href="https://discordapp.com/channels/325477692906536972/360669119948783616" class="nav-link" target="_blank">Chat</a></li>
      <li><a href="https://events.vuejs.org/meetups/" class="nav-link" target="_blank">Meetups (EN)</a></li>
    </ul></li>
    <li><h4>Outils</h4></li>
    <li>
      <ul>
        <li><a href="https://github.com/vuejs/vue-devtools" class="nav-link" target="_blank">Devtools (En)</a></li>
        <li><a href="https://cli.vuejs.org/" class="nav-link" target="_blank">Vue CLI (En)</a></li>
        <li><a href="https://vue-loader.vuejs.org" class="nav-link" target="_blank">Vue Loader (En)</a></li>
      </ul>
    </li>
    <li><h4>Bibliothèques officielles</h4></li>
    <li><ul>
      <li><a href="https://router.vuejs.org/" class="nav-link" target="_blank">Vue Router</a></li>
      <li><a href="https://vuex.vuejs.org/" class="nav-link" target="_blank">Vuex</a></li>
      <li><a href="https://ssr.vuejs.org/" class="nav-link" target="_blank">Vue Server Renderer</a></li>
    </ul></li>
    <li><h4>Infos</h4></li>
    <li><ul>
      <li><a href="https://news.vuejs.org" class="nav-link" target="_blank">Actualités (En)</a></li>
      <li><a href="https://github.com/vuejs/vue/projects/6" class="nav-link" target="_blank">Plans futurs (En)</a></li>
      <li><a href="https://events.vuejs.org/" class="nav-link" target="_blank">Évènements (En)</a></li>
      <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter (En)</a></li>
      <li><a href="https://medium.com/the-vue-point" class="nav-link" target="_blank">Blog (En)</a></li>
      <li><a href="https://vuejobs.com/?ref=vuejs" class="nav-link" target="_blank">Offres d'emploi (En)</a></li>
      <li><a href="https://dev.to/t/vue" class="nav-link" target="_blank">Communauté DEV</a></li>
    </ul></li>
    <li><h4>Liste de ressources</h4></li>
    <li><ul>
      <li><a href="https://github.com/vuejs" class="nav-link" target="_blank">Dépôt officiel (En)</a></li>
      <li><a href="https://curated.vuejs.org/" class="nav-link" target="_blank">Curation Vue (En)</a></li>
      <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank">Awesome Vue (En)</a></li>
    </ul></li>
  </ul>
</li>

<li>
  <a href="/v2/guide/team.html" class="nav-link team">Équipe</a>
</li>
<li class="nav-dropdown-container support-vue">
  <a href="/support-vuejs/" class="nav-link">Soutien</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a href="/support-vuejs/#One-time-Donations" class="nav-link">Don ponctuel</a></li>
      <li><a href="/support-vuejs/#Recurring-Pledges" class="nav-link">Soutien récurrent</a></li>
      <li><a href="https://vue.threadless.com" target="_blank" class="nav-link">La boutique</a></li>
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">Langues</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://cn.vuejs.org/v2/api/index.html" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://jp.vuejs.org/v2/api/index.html" class="nav-link" target="_blank">日本語</a></li>
    <li><a href="https://kr.vuejs.org/v2/api/index.html" class="nav-link" target="_blank">한국어</a></li>
    <li><a href="https://vuejs.org/v2/api/index.html" class="nav-link" target="_blank">English</a></li>
    <li><a href="https://br.vuejs.org/v2/api/index.html" class="nav-link" target="_blank">Português</a></li>
    <li><a href="https://ru.vuejs.org/v2/api/index.html" class="nav-link" target="_blank">Русский</a></li>
    <li><a href="https://vi.vuejs.org/v2/api/index.html" class="nav-link" target="_blank">Tiếng Việt</a></li>
  </ul>
</li>


  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
        
          
  <div class="sidebar">
  <div class="sidebar-inner">
    <ul class="main-menu">
      <li>
  <form id="search-form">
    <input type="text" id="search-query-sidebar" class="search-query st-default-search-input">
  </form>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link current">Doc</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Documentations</h4></li>
    <li>
      <ul>
        <li><a href="/v2/guide/" class="nav-link">Guide</a></li>
        <li><a href="/v2/api/" class="nav-link current">API</a></li>
        <li><a href="/v2/style-guide/" class="nav-link">Conventions</a></li>
        <li><a href="/v2/examples/" class="nav-link">Exemples</a></li>
        <li><a href="/v2/cookbook/" class="nav-link">Tutoriels</a></li>
      </ul>
    </li>
    <li><h4>Videos</h4></li>
    <li>
      <ul>
        <li><a href="https://www.vuemastery.com/courses/" class="nav-link" target="_blank">Vue Mastery (EN)</a></li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container ecosystem">
  <a class="nav-link">Écosystème</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Aide</h4></li>
    <li><ul>
      <li><a href="https://forum.vuejs.org/c/french" class="nav-link" target="_blank">Forum</a></li>
      <li><a href="https://discordapp.com/channels/325477692906536972/360669119948783616" class="nav-link" target="_blank">Chat</a></li>
      <li><a href="https://events.vuejs.org/meetups/" class="nav-link" target="_blank">Meetups (EN)</a></li>
    </ul></li>
    <li><h4>Outils</h4></li>
    <li>
      <ul>
        <li><a href="https://github.com/vuejs/vue-devtools" class="nav-link" target="_blank">Devtools (En)</a></li>
        <li><a href="https://cli.vuejs.org/" class="nav-link" target="_blank">Vue CLI (En)</a></li>
        <li><a href="https://vue-loader.vuejs.org" class="nav-link" target="_blank">Vue Loader (En)</a></li>
      </ul>
    </li>
    <li><h4>Bibliothèques officielles</h4></li>
    <li><ul>
      <li><a href="https://router.vuejs.org/" class="nav-link" target="_blank">Vue Router</a></li>
      <li><a href="https://vuex.vuejs.org/" class="nav-link" target="_blank">Vuex</a></li>
      <li><a href="https://ssr.vuejs.org/" class="nav-link" target="_blank">Vue Server Renderer</a></li>
    </ul></li>
    <li><h4>Infos</h4></li>
    <li><ul>
      <li><a href="https://news.vuejs.org" class="nav-link" target="_blank">Actualités (En)</a></li>
      <li><a href="https://github.com/vuejs/vue/projects/6" class="nav-link" target="_blank">Plans futurs (En)</a></li>
      <li><a href="https://events.vuejs.org/" class="nav-link" target="_blank">Évènements (En)</a></li>
      <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter (En)</a></li>
      <li><a href="https://medium.com/the-vue-point" class="nav-link" target="_blank">Blog (En)</a></li>
      <li><a href="https://vuejobs.com/?ref=vuejs" class="nav-link" target="_blank">Offres d'emploi (En)</a></li>
      <li><a href="https://dev.to/t/vue" class="nav-link" target="_blank">Communauté DEV</a></li>
    </ul></li>
    <li><h4>Liste de ressources</h4></li>
    <li><ul>
      <li><a href="https://github.com/vuejs" class="nav-link" target="_blank">Dépôt officiel (En)</a></li>
      <li><a href="https://curated.vuejs.org/" class="nav-link" target="_blank">Curation Vue (En)</a></li>
      <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank">Awesome Vue (En)</a></li>
    </ul></li>
  </ul>
</li>

<li>
  <a href="/v2/guide/team.html" class="nav-link team">Équipe</a>
</li>
<li class="nav-dropdown-container support-vue">
  <a href="/support-vuejs/" class="nav-link">Soutien</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a href="/support-vuejs/#One-time-Donations" class="nav-link">Don ponctuel</a></li>
      <li><a href="/support-vuejs/#Recurring-Pledges" class="nav-link">Soutien récurrent</a></li>
      <li><a href="https://vue.threadless.com" target="_blank" class="nav-link">La boutique</a></li>
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">Langues</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://cn.vuejs.org/v2/api/index.html" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://jp.vuejs.org/v2/api/index.html" class="nav-link" target="_blank">日本語</a></li>
    <li><a href="https://kr.vuejs.org/v2/api/index.html" class="nav-link" target="_blank">한국어</a></li>
    <li><a href="https://vuejs.org/v2/api/index.html" class="nav-link" target="_blank">English</a></li>
    <li><a href="https://br.vuejs.org/v2/api/index.html" class="nav-link" target="_blank">Português</a></li>
    <li><a href="https://ru.vuejs.org/v2/api/index.html" class="nav-link" target="_blank">Русский</a></li>
    <li><a href="https://vi.vuejs.org/v2/api/index.html" class="nav-link" target="_blank">Tiếng Việt</a></li>
  </ul>
</li>


    </ul>
    <div class="list">
      <div id="sidebar-sponsors-special">
  <div class="main-sponsor">
    <span>Special Sponsor</span>
    <div>
    <a href="https://stdlib.com/" target="_blank" class="logo">
      <img src="/images/stdlib.png" alt="">
    </a>
    </div>
  </div>
</div>

<div id="sidebar-sponsors-platinum-left">
  <div class="main-sponsor">
    <span>Sponsors de platine</span>
    <div>
    <a href="https://moduscreate.com/?utm_source=Vue&utm_medium=Partnership&utm_campaign=VueShip" target="_blank" class="logo">
      <img src="/images/modus.png" alt="Modus">
    </a>
    <a href="https://www.bitsrc.io/?utm_source=vue&utm_medium=vue&utm_campaign=vue&utm_term=vue&utm_content=vue" target="_blank" class="logo">
      <img src="/images/bit.png" alt="Bit">
    </a>
    <a href="http://tooltwist.com/" target="_blank" class="logo">
      <img src="/images/tooltwist.png" alt="Tooltwist">
    </a>
    <a href="https://vueschool.io/?utm_source=Vuejs.org&utm_medium=Banner&utm_campaign=Sponsored%20Banner&utm_content=V1" target="_blank" class="logo">
      <img src="/images/vueschool.png" alt="VueSchool">
    </a>
    <a href="https://vehikl.com/" target="_blank" class="logo">
      <img src="/images/vehikl.png" alt="Vehikl">
    </a>
    <a href="https://www.nativescript.org/vue?utm_source=vue-js-org&utm_medium=website&utm_campaign=nativescript-awareness" target="_blank" class="logo">
      <img src="/images/nativescript.png" alt="NativeScript">
    </a>
    </div>
  </div>
  <a class="become-backer" href="/support-vuejs">
    Devenez un sponsor
  </a>
</div>


      
        <h2>
          
          API
          
            <select class="version-select">
              <option value="SELF" selected>2.x</option>
              <option value="v1">1.0</option>
              <option value="012">0.12</option>
              <option value="011">0.11</option>
            </select>
          
        </h2>
        <ul class="menu-root">
  
</ul>

      
    </div>
  </div>
</div>

<div id="sidebar-sponsors-platinum-right">
  <div class="main-sponsor">
    <span>Sponsors de platine</span>
    <div>
    <a href="https://moduscreate.com/?utm_source=Vue&utm_medium=Partnership&utm_campaign=VueShip" target="_blank" class="logo">
      <img src="/images/modus.png" alt="Modus">
    </a>
    <a href="https://www.bitsrc.io/?utm_source=vue&utm_medium=vue&utm_campaign=vue&utm_term=vue&utm_content=vue" target="_blank" class="logo">
      <img src="/images/bit.png" alt="Bit">
    </a>
    <a href="http://tooltwist.com/" target="_blank" class="logo">
      <img src="/images/tooltwist.png" alt="Tooltwist">
    </a>
    <a href="https://vueschool.io/?utm_source=Vuejs.org&utm_medium=Banner&utm_campaign=Sponsored%20Banner&utm_content=V1" target="_blank" class="logo">
      <img src="/images/vueschool.png" alt="VueSchool">
    </a>
    <a href="https://vehikl.com/" target="_blank" class="logo">
      <img src="/images/vehikl.png" alt="Vehikl">
    </a>
    <a href="https://www.nativescript.org/vue?utm_source=vue-js-org&utm_medium=website&utm_campaign=nativescript-awareness" target="_blank" class="logo">
      <img src="/images/nativescript.png" alt="NativeScript">
    </a>
    </div>
  </div>
  <a class="become-backer" href="/support-vuejs">
    Devenez un sponsor
  </a>
</div>



<div class="content api with-sidebar ">
  
    
      <div id="ad">
  <script
    async
    type="text/javascript"
    src="//cdn.carbonads.com/carbon.js?serve=CKYIK2QU&placement=vuejsorg"
    id="_carbonads_js">
  </script>
</div>

    
  
  
    <h1>API</h1>
  
  
    <h2 id="Configuration-globale"><a href="#Configuration-globale" class="headerlink" title="Configuration globale"></a>Configuration globale</h2><p><code>Vue.config</code> est un objet contenant les configurations globales de Vue. Vous pouvez modifier les propriétés listées ci-dessous avant de mettre en place votre application :</p>
<h3 id="silent"><a href="#silent" class="headerlink" title="silent"></a>silent</h3><ul>
<li><p><strong>Type :</strong> <code>boolean</code></p>
</li>
<li><p><strong>Par défaut :</strong> <code>false</code></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<pre><code class="hljs js">Vue.config.silent = <span class="hljs-literal">true</span></code></pre>
<p>Supprime tous les logs et warnings de Vue.js.</p>
</li>
</ul>
<h3 id="optionMergeStrategies"><a href="#optionMergeStrategies" class="headerlink" title="optionMergeStrategies"></a>optionMergeStrategies</h3><ul>
<li><p><strong>Type :</strong> <code>{ [key: string]: Function }</code></p>
</li>
<li><p><strong>Par défaut :</strong> <code>{}</code></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<pre><code class="hljs js">Vue.config.optionMergeStrategies._mon_option = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent, enfant, vm</span>) </span>&#123;
  <span class="hljs-keyword">return</span> enfant + <span class="hljs-number">1</span>
&#125;

<span class="hljs-keyword">const</span> Profil = Vue.extend(&#123;
  <span class="hljs-attr">_mon_option</span>: <span class="hljs-number">1</span>
&#125;)

<span class="hljs-comment">// Profil.options._mon_option = 2</span></code></pre>
<p>Définit des stratégies personnalisées de fusion pour les options.</p>
<p>La stratégie de fusion reçoit en arguments la valeur de cette option définie dans le parent et les instances enfants en tant que premier et second argument, respectivement. L’instance de Vue est passée en troisième argument.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/mixins.html#Strategie-de-fusion-des-options-personnalisees">Stratégie de fusion des options personnalisées</a></p>
</li>
</ul>
<h3 id="devtools"><a href="#devtools" class="headerlink" title="devtools"></a>devtools</h3><ul>
<li><p><strong>Type :</strong> <code>boolean</code></p>
</li>
<li><p><strong>Par défaut :</strong> <code>true</code> (<code>false</code> dans les versions de production)</p>
</li>
<li><p><strong>Utilisation :</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// assurez-vous d'assigner ça de manière synchrone immédiatement après avoir chargé Vue</span>
Vue.config.devtools = <span class="hljs-literal">true</span></code></pre>
<p>Autorise ou non l’inspection des <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener">vue-devtools</a>. Cette option a comme valeur par défaut <code>true</code> dans les versions de développement et <code>false</code> dans les versions de production. Vous pouvez l’assigner à <code>true</code> pour activer l’inspection avec les versions de production.</p>
</li>
</ul>
<h3 id="errorHandler"><a href="#errorHandler" class="headerlink" title="errorHandler"></a>errorHandler</h3><ul>
<li><p><strong>Type :</strong> <code>Function</code></p>
</li>
<li><p><strong>Par défaut :</strong> <code>undefined</code></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<pre><code class="hljs js">Vue.config.errorHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, vm, info</span>) </span>&#123;
  <span class="hljs-comment">// gérer le cas d'erreur `info` est une information spécifique</span>
  <span class="hljs-comment">// à Vue sur l'erreur, par exemple dans quel hook du cycle de vie</span>
  <span class="hljs-comment">// l'erreur a été trouvée. Disponible uniquement en 2.2.0+</span>
&#125;</code></pre>
<p>Définit un gestionnaire pour les erreurs non interceptées pendant le rendu d’un composant et les appels aux observateurs. Ce gestionnaire sera appelé avec comme arguments l’erreur et l’instance de Vue associée.</p>
<blockquote>
<p>En 2.2.0+, ce hook capture également les erreurs dans les hooks du cycle de vie des composants. De plus, quand ce hook est <code>undefined</code>, les erreurs capturées seront loguées avec <code>console.error</code> plutôt qu’avoir un crash de l’application.</p>
</blockquote>
<blockquote>
<p>En 2.4.0+ ce hook capture également les erreurs lancées depuis un gestionnaire d’évènement Vue personnalisé.</p>
</blockquote>
<blockquote>
<p>En 2.6.0+, ce hook capture également les erreurs lancées depuis les écouteurs de DOM <code>v-on</code>. De plus, si les hooks couverts ou gestionnaires retournent une chaine de Promesse (par exemple les fonctions async), l’erreur sera également remontée depuis cette Promesse.</p>
</blockquote>
<blockquote>
<p><a href="https://sentry.io" target="_blank" rel="noopener">Sentry</a> et <a href="https://docs.bugsnag.com/platforms/browsers/vue/" target="_blank" rel="noopener">Bugsnag</a> fournissent une intégration officielle utilisant cette option.</p>
</blockquote>
</li>
</ul>
<h3 id="warnHandler"><a href="#warnHandler" class="headerlink" title="warnHandler"></a>warnHandler</h3><blockquote>
<p>Nouveau dans la 2.4.0+</p>
</blockquote>
<ul>
<li><p><strong>Type :</strong> <code>Function</code></p>
</li>
<li><p><strong>*Par défaut :</strong> <code>undefined</code></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<pre><code class="hljs js">Vue.config.warnHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg, vm, trace</span>) </span>&#123;
  <span class="hljs-comment">// `trace` est la trace de hiérarchie de composant</span>
&#125;</code></pre>
<p>Assigne un gestionnaire personnalisé pour les avertissements à l’exécution de Vue. Notez que cela n’est fonctionnel qu’en développement et est ignoré en production.</p>
</li>
</ul>
<h3 id="ignoredElements"><a href="#ignoredElements" class="headerlink" title="ignoredElements"></a>ignoredElements</h3><ul>
<li><p><strong>Type :</strong> <code>Array&lt;string | RegExp&gt;</code></p>
</li>
<li><p><strong>Par défaut :</strong> <code>[]</code></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<pre><code class="hljs js">Vue.config.ignoredElements = [
  'mon-web-component',
  'un-autre-web-component',
  // Utilisez une `RegExp` pour ignorer tous les éléments qui commencent par « ion- »
  // 2.5+ seulement
  /^ion-/
]</code></pre>
<p>Indique à Vue d’ignorer les éléments personnalisés définis en dehors de Vue (ex. : en utilisant les API Web Components). Autrement, un message d’avertissement <code>Unknown custom element</code> sera affiché, supposant que vous avez oublié d’inscrire un composant global ou fait une faute de frappe dans son nom.</p>
</li>
</ul>
<h3 id="keyCodes"><a href="#keyCodes" class="headerlink" title="keyCodes"></a>keyCodes</h3><ul>
<li><p><strong>Type :</strong> <code>{ [key: string]: number | Array&lt;number&gt; }</code></p>
</li>
<li><p><strong>Par défaut :</strong> <code>{}</code></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<pre><code class="hljs js">Vue.config.keyCodes = &#123;
  <span class="hljs-attr">v</span>: <span class="hljs-number">86</span>,
  <span class="hljs-attr">f1</span>: <span class="hljs-number">112</span>,
  <span class="hljs-comment">// La camelCase ne marche pas</span>
  mediaPlayPause: <span class="hljs-number">179</span>,
  <span class="hljs-comment">// à la place vous devez utiliser la kebab-case avec des guillemets doubles</span>
  <span class="hljs-string">"media-play-pause"</span>: <span class="hljs-number">179</span>,
  <span class="hljs-attr">up</span>: [<span class="hljs-number">38</span>, <span class="hljs-number">87</span>]
&#125;</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> @<span class="hljs-attr">keyup.media-play-pause</span>=<span class="hljs-string">"method"</span>&gt;</span></code></pre>
<p>Définit des alias pour les touches avec <code>v-on</code>.</p>
</li>
</ul>
<h3 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h3><blockquote>
<p>Nouveau dans la 2.2.0+</p>
</blockquote>
<ul>
<li><p><strong>Type :</strong> <code>boolean</code></p>
</li>
<li><p><strong>Par défaut :</strong> <code>false</code> (à partir de la 2.2.3+)</p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Assignez ceci à <code>true</code> pour activer le suivi des performances pour l’initialisation, la compilation, le rendu et la mise à jour des composants dans la timeline des outils développeur des navigateurs. Fonctionne uniquement en mode développement et dans les navigateurs supportant l’API <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark" target="_blank" rel="noopener">performance.mark</a>.</p>
</li>
</ul>
<h3 id="productionTip"><a href="#productionTip" class="headerlink" title="productionTip"></a>productionTip</h3><blockquote>
<p>Nouveau dans la 2.2.0+</p>
</blockquote>
<ul>
<li><p><strong>Type :</strong> <code>boolean</code></p>
</li>
<li><p><strong>Par défaut :</strong> <code>true</code></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Assignez ceci à <code>false</code> pour ne plus avoir la notification de production au démarrage de Vue.</p>
</li>
</ul>
<h2 id="API-globale"><a href="#API-globale" class="headerlink" title="API globale"></a>API globale</h2><h3 id="Vue-extend-options"><a href="#Vue-extend-options" class="headerlink" title="Vue.extend( options )"></a>Vue.extend( options )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{Object} options</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Crée une « sous-classe » du constructeur de base Vue. L’argument doit être un objet contenant les options du composant.</p>
<p>Le cas spécial à noter ici est l’option <code>data</code> - il doit s’agir d’une fonction quand utilisé avec <code>Vue.extend()</code>.</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"point-de-montage"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js"><span class="hljs-comment">// crée un constructeur réutilisable</span>
<span class="hljs-keyword">var</span> Profil = Vue.extend(&#123;
  <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;p&gt;&#123;&#123;prenom&#125;&#125; &#123;&#123;nom&#125;&#125; alias &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,
  <span class="hljs-attr">data</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">prenom</span>: <span class="hljs-string">'Walter'</span>,
      <span class="hljs-attr">nom</span>: <span class="hljs-string">'White'</span>,
      <span class="hljs-attr">alias</span>: <span class="hljs-string">'Heisenberg'</span>
    &#125;
  &#125;
&#125;)
<span class="hljs-comment">// crée une instance de Profil et la monte sur un élément</span>
<span class="hljs-keyword">new</span> Profil().$mount(<span class="hljs-string">'#point-de-montage'</span>)</code></pre>
<p>Cela donnera comme résultat :</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Walter White aka Heisenberg<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/components.html">Composants</a></p>
</li>
</ul>
<h3 id="Vue-nextTick-callback-contexte"><a href="#Vue-nextTick-callback-contexte" class="headerlink" title="Vue.nextTick( [callback, contexte] )"></a>Vue.nextTick( [callback, contexte] )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{Function} [callback]</code></li>
<li><code>{Object} [contexte]</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Reporte l’exécution de la fonction de rappel au prochain cycle de mise à jour du DOM. Utilisez-le immédiatement après avoir changé des données afin d’attendre la mise à jour du DOM.</p>
<pre><code class="hljs js"><span class="hljs-comment">// modification de données</span>
vm.msg = <span class="hljs-string">'Salut'</span>
<span class="hljs-comment">// le DOM n'a pas encore été mis à jour</span>
Vue.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// le DOM est à jour</span>
&#125;)

<span class="hljs-comment">// utilisation en tant que promesse (2.1.0+, voir la note ci-dessous)</span>
Vue.nextTick()
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// le DOM est à jour</span>
  &#125;)</code></pre>
<blockquote>
<p>Nouveauté de la 2.1.0+ : retourne une promesse si aucune fonction de rappel n’est fournie et si les promesses sont supportées par l’environnement d’exécution. Notez que Vue ne fournit pas de polyfill aux promesses. Aussi, si vous ciblez des navigateurs qui ne supportent pas les promesses nativement (on parle de toi, IE), vous pouvez fournir un polyfill vous-même.</p>
</blockquote>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/reactivity.html#File-d’attente-de-mise-a-jour-asynchrone">File d’attente de mise à jour asynchrone</a></p>
</li>
</ul>
<h3 id="Vue-set-cible-nomDePropriete-index-valeur"><a href="#Vue-set-cible-nomDePropriete-index-valeur" class="headerlink" title="Vue.set( cible, nomDePropriete/index, valeur )"></a>Vue.set( cible, nomDePropriete/index, valeur )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{Object | Array} cible</code></li>
<li><code>{string | number} nomDePropriete/index</code></li>
<li><code>{any} valeur</code></li>
</ul>
</li>
<li><p><strong>Retourne:</strong> la valeur assignée.</p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Assigne une propriété à un objet réactif, s’assurant que la nouvelle propriété soit également réactive de manière à déclencher une nouvelle mise à jour de la vue. Ceci doit être utilisé pour les nouvelles propriétés d’objets réactifs car Vue ne peut pas détecter normalement les ajouts de propriétés (par ex. <code>this.myObject.newProperty = &#39;bonjour&#39;</code>).</p>
<p class="tip">L’objet ne peut pas être une instance de Vue, ou l’objet de données à la racine d’une instance de Vue.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/reactivity.html">Réactivité en détail</a></p>
</li>
</ul>
<h3 id="Vue-delete-cible-nomDePropriete-index"><a href="#Vue-delete-cible-nomDePropriete-index" class="headerlink" title="Vue.delete( cible, nomDePropriete/index )"></a>Vue.delete( cible, nomDePropriete/index )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{Object | Array} cible</code></li>
<li><code>{string | number} nomDePropriete/index</code></li>
</ul>
<blockquote>
<p>Seulement dans la 2.2.0+ : fonctionne aussi avec Array + index.</p>
</blockquote>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Supprime une propriété d’un objet cible. Si l’objet est réactif, cette méthode s’assure que la suppression déclenche les mises à jour de la vue. Ceci est principalement utilisé pour passer outre la limitation de Vue qui est de ne pas pouvoir détecter automatiquement la suppression de propriétés, mais vous devriez rarement en avoir besoin.</p>
<p class="tip">L’objet cible ne peut pas être une instance de Vue, ou l’objet de données à la racine d’une instance de Vue.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/reactivity.html">Réactivité en détail</a></p>
</li>
</ul>
<h3 id="Vue-directive-id-definition"><a href="#Vue-directive-id-definition" class="headerlink" title="Vue.directive( id, [définition] )"></a>Vue.directive( id, [définition] )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{string} id</code></li>
<li><code>{Function | Object} [définition]</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Inscrit ou récupère une directive globale.</p>
<pre><code class="hljs js"><span class="hljs-comment">// inscrit une directive</span>
Vue.directive(<span class="hljs-string">'ma-directive'</span>, &#123;
  <span class="hljs-attr">bind</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,
  <span class="hljs-attr">inserted</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,
  <span class="hljs-attr">update</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,
  <span class="hljs-attr">componentUpdated</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,
  <span class="hljs-attr">unbind</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;
&#125;)

<span class="hljs-comment">// inscription (directive comme simple fonction)</span>
Vue.directive(<span class="hljs-string">'ma-directive'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// cette fonction sera appelée comme `bind` et `update` ci-dessus</span>
&#125;)

<span class="hljs-comment">// accesseur, retourne la définition de la directive si inscrite</span>
<span class="hljs-keyword">var</span> maDirective = Vue.directive(<span class="hljs-string">'ma-directive'</span>)</code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/custom-directive.html">Directives personnalisées</a></p>
</li>
</ul>
<h3 id="Vue-filter-id-definition"><a href="#Vue-filter-id-definition" class="headerlink" title="Vue.filter( id, [définition] )"></a>Vue.filter( id, [définition] )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{string} id</code></li>
<li><code>{Function} [définition]</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Inscrit ou récupère un filtre global.</p>
<pre><code class="hljs js"><span class="hljs-comment">// inscrit un filtre</span>
Vue.filter(<span class="hljs-string">'mon-filtre'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;
  <span class="hljs-comment">// retourne la valeur modifiée</span>
&#125;)

<span class="hljs-comment">// accesseur, retourne le filtre si inscrit</span>
<span class="hljs-keyword">var</span> monFiltre = Vue.filter(<span class="hljs-string">'mon-filtre'</span>)</code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/filters.html">Filtres</a></p>
</li>
</ul>
<h3 id="Vue-component-id-definition"><a href="#Vue-component-id-definition" class="headerlink" title="Vue.component( id, [définition] )"></a>Vue.component( id, [définition] )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{string} id</code></li>
<li><code>{Function | Object} [définition]</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Inscrit ou récupère un composant global. L’inscription assigne aussi automatiquement la propriété <code>name</code> du composant au paramètre <code>id</code> donné.</p>
<pre><code class="hljs js"><span class="hljs-comment">// inscrit un constructeur étendu</span>
Vue.component(<span class="hljs-string">'mon-composant'</span>, Vue.extend(&#123; <span class="hljs-comment">/* ... */</span> &#125;))

<span class="hljs-comment">// inscrit un composant avec un objet options (appelle automatiquement Vue.extend)</span>
Vue.component(<span class="hljs-string">'mon-composant'</span>, &#123; <span class="hljs-comment">/* ... */</span> &#125;)

<span class="hljs-comment">// récupère un composant inscrit (retourne toujours le constructeur)</span>
<span class="hljs-keyword">var</span> MonComposant = Vue.component(<span class="hljs-string">'mon-composant'</span>)</code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/components.html">Composants</a></p>
</li>
</ul>
<h3 id="Vue-use-plugin"><a href="#Vue-use-plugin" class="headerlink" title="Vue.use( plugin )"></a>Vue.use( plugin )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{Object | Function} plugin</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Cette méthode doit être appelée avant d’appeler <code>new Vue()</code></p>
<p>Installe un plugin Vue.js. Si l’argument plugin est de type <code>Object</code>, il doit exposer une méthode  <code>install</code>. S’il s’agit d’une fonction, elle sera utilisée comme méthode d’installation. Cette méthode d’installation sera appelée avec Vue en tant qu’argument.</p>
<p>Quand cette méthode est appelée avec le même plugin plusieurs fois, le plugin ne sera installé qu’une seule fois.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/plugins.html">Plugins</a></p>
</li>
</ul>
<h3 id="Vue-mixin-mixin"><a href="#Vue-mixin-mixin" class="headerlink" title="Vue.mixin( mixin )"></a>Vue.mixin( mixin )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{Object} mixin</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Applique une mixin globale, qui affecte toutes les instances de Vue créées par la suite. Cela peut être utilisé par les créateurs de plugins pour injecter un composant personnalisé dans les composants. <strong>Non recommandé dans le code applicatif</strong>.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/mixins.html#Mixin-global">Mixin global</a></p>
</li>
</ul>
<h3 id="Vue-compile-template"><a href="#Vue-compile-template" class="headerlink" title="Vue.compile( template )"></a>Vue.compile( template )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{string} template</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Compile une string template en une fonction de rendu. <strong>Disponible uniquement sur la version complète.</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> res = Vue.compile(<span class="hljs-string">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)

<span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">data</span>: &#123;
    <span class="hljs-attr">msg</span>: <span class="hljs-string">'salut'</span>
  &#125;,
  <span class="hljs-attr">render</span>: res.render,
  <span class="hljs-attr">staticRenderFns</span>: res.staticRenderFns
&#125;)</code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/render-function.html">Fonctions de rendu</a></p>
</li>
</ul>
<h3 id="Vue-observable-object"><a href="#Vue-observable-object" class="headerlink" title="Vue.observable( object )"></a>Vue.observable( object )</h3><blockquote>
<p>Nouveau en 2.6.0+</p>
</blockquote>
<ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{Object} object</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Rend un objet réactif. En interne, Vue l’utilise sur l’objet retourné par la fonction <code>data</code>.</p>
<p>L’objet retourné peut être directement utilisé à l’intérieur des <a href="../guide/render-function.html">fonctions de rendu</a> ainsi que des <a href="../guide/computed.html">propriétés calculées</a>. Il déclenchera les mises à jour appropriées lors de mutations. Il peut également être utilisé comme un store minimal intercomposant dans des scénarios basiques :</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> state = Vue.observable(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)

<span class="hljs-keyword">const</span> Demo = &#123;
  render(h) &#123;
    <span class="hljs-keyword">return</span> h(<span class="hljs-string">'button'</span>, &#123;
      <span class="hljs-attr">on</span>: &#123; <span class="hljs-attr">click</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; state.count++ &#125;&#125;
    &#125;, <span class="hljs-string">`le compteur est : <span class="hljs-subst">$&#123;state.count&#125;</span>`</span>)
  &#125;
&#125;</code></pre>
<p class="tip">Dans Vue 2.x, <code>Vue.observable</code> mute directement l’objet qui lui est transmis, de sorte qu’il soit équivalent à l’objet renvoyé, comme <a href="../guide/instance.html#Donnees-et-methodes">démontré ici</a>. Dans Vue 3.x, un proxy réactif sera retourné à la place, laissant l’objet original non réactif s’il est muté directement. Cependant, pour de futures compatibilités, nous recommandons toujours de travailler avec l’objet retourné par <code>Vue.observable</code>, au lieu de l’objet originel.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/reactivity.html">Réactivité en détail</a></p>
</li>
</ul>
<h3 id="Vue-version"><a href="#Vue-version" class="headerlink" title="Vue.version"></a>Vue.version</h3><ul>
<li><p><strong>Détails :</strong> donne la version de Vue installée sous forme de <code>String</code>. C’est particulièrement utile pour les plugins et les composants de la communauté, où vous pouvez être amenés à utiliser différentes stratégies pour différentes versions.</p>
</li>
<li><p><strong>Utilisation :</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> version = <span class="hljs-built_in">Number</span>(Vue.version.split(<span class="hljs-string">'.'</span>)[<span class="hljs-number">0</span>])

<span class="hljs-keyword">if</span> (version === <span class="hljs-number">2</span>) &#123;
  <span class="hljs-comment">// Vue v2.x.x</span>
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (version === <span class="hljs-number">1</span>) &#123;
  <span class="hljs-comment">// Vue v1.x.x</span>
&#125; <span class="hljs-keyword">else</span> &#123;
  <span class="hljs-comment">// Versions non supportées de Vue</span>
&#125;</code></pre>
</li>
</ul>
<h2 id="Options-Data"><a href="#Options-Data" class="headerlink" title="Options / Data"></a>Options / Data</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><ul>
<li><p><strong>Type :</strong> <code>Object | Function</code></p>
</li>
<li><p><strong>Restriction :</strong> accepte uniquement une fonction lorsqu’utilisé dans une définition de composant.</p>
</li>
<li><p><strong>Détails :</strong></p>
<p>L’objet de données pour l’instance de Vue. Vue va de manière récursive convertir ses propriétés en des accesseurs / mutateurs (<em>getter/setters</em>) afin de les rendre « réactives ». <strong>L’objet doit être un simple objet de base</strong>: les objets natifs tels que les API du navigateur et les propriétés issues du prototype sont ignorées. Une règle d’or est que la donnée doit juste être de la donnée. Il n’est pas recommandé d’observer des objets ayant leur propre comportement avec états.</p>
<p>Une fois observé, vous ne pouvez plus ajouter de propriétés réactives à l’objet de données racine. C’est pourquoi il est recommandé de déclarer dès le départ toutes les propriétés réactives à la racine de l’objet de données, avant de créer l’instance.</p>
<p>Après que l’instance ait été créée, l’objet de données initial peut être accédé via <code>vm.$data</code>. L’instance de Vue servira également de proxy pour toutes les propriétés trouvées dans l’objet de données, donc <code>vm.a</code> sera l’équivalent de <code>vm.$data.a</code>.</p>
<p>Les propriétés commençant par <code>_</code> ou <code>$</code> ne seront <strong>pas</strong> proxyfiées par l’instance de Vue car elles pourraient entrer en conflit avec certaines propriétés internes et méthodes d’API de Vue. Vous devrez y accéder via <code>vm.$data._propriete</code>.</p>
<p>Lors de la définition d’un <strong>composant</strong>, la propriété <code>data</code> doit être déclarée en tant que fonction retournant l’objet de données initial, car il y aura plusieurs instances créées utilisant la même définition. Si nous utilisons un objet classique pour <code>data</code>, le même objet sera <strong>partagé par référence</strong> à toutes les instances créées ! En fournissant une fonction <code>data</code> , chaque fois qu’une nouvelle instance est créée, nous l’appelons simplement afin de récupérer une copie fraiche des données initiales.</p>
<p>Si nécessaire, un clone profond de l’objet original peut être obtenu en passant <code>vm.$data</code> à travers <code>JSON.parse(JSON.stringify(...))</code>.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> data = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;

<span class="hljs-comment">// création directe d'instances</span>
<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">data</span>: data
&#125;)
vm.a <span class="hljs-comment">// =&gt; 1</span>
vm.$data === data <span class="hljs-comment">// =&gt; true</span>

<span class="hljs-comment">// data doit être une fonction lorsqu'utilisée dans Vue.extend()</span>
<span class="hljs-keyword">var</span> Composant = Vue.extend(&#123;
  <span class="hljs-attr">data</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;
  &#125;
&#125;)</code></pre>
<p>Notez que si vous utilisez la fonctions fléchées avec la propriété <code>data</code>, <code>this</code> ne sera plus l’instance du composant, mais vous pouvez toujours la récupérer en tant que premier argument de la fonction :</p>
<pre><code class="hljs js">data: <span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> (&#123; <span class="hljs-attr">a</span>: vm.myProp &#125;)</code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/reactivity.html">Réactivité en détail</a></p>
</li>
</ul>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><ul>
<li><p><strong>Type :</strong> <code>Array&lt;string&gt; | Object</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Une liste ou un objet décrivant les attributs exposés par le composant afin de passer des données depuis le composant parent. Ce paramètre a une syntaxe simple basée sur un tableau (<code>Array</code>) et une syntaxe alternative basée sur un objet (<code>Object</code>) qui permet une configuration avancée telle qu’une vérification de typage, des contrôles de validation personnalisés et des valeurs par défaut.</p>
<p>Avec la syntaxe objet, vous pouvez passer les options suivantes :</p>
<ul>
<li>Le <code>type</code> peut être l’un des constructeurs natifs suivants : <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Array</code>, <code>Object</code>, <code>Date</code>, <code>Function</code>, <code>Symbol</code> ainsi que n’importe quelle fonction de construction ou tableau de ces types. Les types des props seront vérifiés. Un avertissement sera fourni si une prop n’est pas du bon type. <a href="../guide/components-props.html#Types-des-props">Plus d’information</a> sur les types des props.</li>
<li><code>default:</code> <code>any</code><br>Spécifie la valeur par défaut de la prop. Si la prop n’est pas passée, cette valeur sera utilisée à la place. Les objets ou tableaux par défaut doivent être retournés depuis une fonction de fabrique.</li>
<li><code>required:</code> <code>Boolean</code><br>Définie si la prop est requise. Dans un environnement autre que de production, un avertissement sera affiché dans la console si cette valeur est évaluée à vrai et que la prop n’est pas passée.</li>
<li><code>validator:</code> <code>Function</code><br>Une fonction de validation personnalisée qui prend la valeur de prop comme seul argument. Dans un environnement autre que de production, un avertissement sera affiché dans la console si cette fonction retourne une valeur évaluée à faux. (c.-à-d. que la validation a échoué). Vous pouvez en lire plus à propos de la validation des props <a href="../guide/components-props.html#Validation-des-props">ici</a>.</li>
</ul>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// syntaxe simple</span>
Vue.component(<span class="hljs-string">'props-démo-simple'</span>, &#123;
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'taille'</span>, <span class="hljs-string">'monMessage'</span>]
&#125;)

<span class="hljs-comment">// syntaxe avancée avec validation</span>
Vue.component(<span class="hljs-string">'props-démo-avancée'</span>, &#123;
  <span class="hljs-attr">props</span>: &#123;
    <span class="hljs-comment">// juste une vérification de type</span>
    hauteur: <span class="hljs-built_in">Number</span>,
    <span class="hljs-comment">// vérification du type ainsi que d'autres validations</span>
    âge: &#123;
      <span class="hljs-attr">type</span> : <span class="hljs-built_in">Number</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">valeur</span>) </span>&#123;
        <span class="hljs-keyword">return</span> valeur &gt;= <span class="hljs-number">0</span>
      &#125;
    &#125;
  &#125;
&#125;)</code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/components-props.html">Props</a></p>
</li>
</ul>
<h3 id="propsData"><a href="#propsData" class="headerlink" title="propsData"></a>propsData</h3><ul>
<li><p><strong>Type :</strong> <code>{ [key: string]: any }</code></p>
</li>
<li><p><strong>Restriction :</strong> utilisé uniquement si l’instance est créée via <code>new</code>.</p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Passe des valeurs d’attribut à l’instance durant sa création. Cette propriété a pour but principal de faciliter les tests unitaires.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> Comp = Vue.extend(&#123;
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'msg'</span>],
  <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span>
&#125;)

<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Comp(&#123;
  <span class="hljs-attr">propsData</span>: &#123;
    <span class="hljs-attr">msg</span>: <span class="hljs-string">'salut'</span>
  &#125;
&#125;)</code></pre>
</li>
</ul>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><ul>
<li><p><strong>Type :</strong> <code>{ [key: string]: Function | { get: Function, set: Function } }</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Les propriétés calculées qui seront ajoutées à l’instance de Vue. Tous les accesseurs (« getters ») et mutateurs (« setters ») ont leur contexte <code>this</code> automatiquement lié à l’instance de Vue.</p>
<p>Notez que si vous utilisez la fonctions fléchées avec la propriété <code>data</code>, <code>this</code> ne sera plus l’instance du composant, mais vous pouvez toujours la récupérer en tant que premier argument de la fonction :</p>
<pre><code class="hljs js">computed: &#123;
  <span class="hljs-attr">aDouble</span>: <span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> vm.a * <span class="hljs-number">2</span>
&#125;</code></pre>
<p>Les propriétés calculées sont mises en cache, et réévaluées uniquement lorsque leurs dépendances réactives changent. Notez que si une certaine dépendance est en dehors de la portée de l’instance (et donc non réactive), la propriété calculée ne sera <strong>pas</strong> mise à jour.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;,
  <span class="hljs-attr">computed</span>: &#123;
    <span class="hljs-comment">// accesseur uniquement</span>
    aDouble: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a * <span class="hljs-number">2</span>
    &#125;,
    <span class="hljs-comment">// accesseur et mutateur à la fois</span>
    aPlus: &#123;
      <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a + <span class="hljs-number">1</span>
      &#125;,
      <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>&#123;
        <span class="hljs-keyword">this</span>.a = v - <span class="hljs-number">1</span>
      &#125;
    &#125;
  &#125;
&#125;)
vm.aPlus   <span class="hljs-comment">// =&gt; 2</span>
vm.aPlus = <span class="hljs-number">3</span>
vm.a       <span class="hljs-comment">// =&gt; 2</span>
vm.aDouble <span class="hljs-comment">// =&gt; 4</span></code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/computed.html">Propriétés calculées</a></p>
</li>
</ul>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><ul>
<li><p><strong>Type :</strong> <code>{ [key: string]: Function }</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Les méthodes qui seront ajoutées à l’instance de Vue. Vous pouvez accéder à ces méthodes directement depuis l’instance VM ou les utiliser à travers des expressions de directives. Toutes les méthodes ont leur contexte d’appel <code>this</code> automatiquement assigné à l’instance de Vue.</p>
<p class="tip">Notez que <strong>vous ne devriez pas utiliser de fonctions fléchées pour définir une méthode</strong> (exemple: <code>plus: () =&gt; this.a++</code>). La raison est que les fonctions fléchées sont liées au contexte parent, donc <code>this</code> ne correspondra pas à l’instance de Vue et <code>this.a</code> vaudra <code>undefined</code>.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-attr">plus</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-keyword">this</span>.a++
    &#125;
  &#125;
&#125;)
vm.plus()
vm.a <span class="hljs-comment">// 2</span></code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/events.html">Gestion des évènements</a></p>
</li>
</ul>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul>
<li><p><strong>Type :</strong> <code>{ [key: string]: string | Function | Object | Array }</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Un objet où les clés sont des expressions à surveiller et où la valeur associée est la fonction de rappel exécutée quand cette expression change. On parle alors d’observateur ou <em>watcher</em> pour décrire ce lien. La valeur peut également être une <code>String</code> correspondant au nom d’une méthode de l’instance, ou un objet avec des options avancées. L’instance de Vue appellera <code>$watch()</code> pour chaque clé de l’objet à l’initialisation.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">data</span>: &#123;
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>,
    <span class="hljs-attr">e</span>: &#123;
      <span class="hljs-attr">f</span>: &#123;
        <span class="hljs-attr">g</span>: <span class="hljs-number">5</span>
      &#125;
    &#125;
  &#125;,
  <span class="hljs-attr">watch</span>: &#123;
    <span class="hljs-attr">a</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">valeur, ancienneValeur</span>) </span>&#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'nouveau: %s, ancien: %s'</span>, valeur, ancienneValeur)
    &#125;,
    <span class="hljs-comment">// nom d'une méthode</span>
    b: <span class="hljs-string">'uneMéthode'</span>,
    <span class="hljs-comment">// la fonction de rappel sera appelée quelque soit les changements des propriétés de l'objet observé indépendamment de leur profondeur</span>
    c: &#123;
      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">valeur, ancienneValeur</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;,
      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>
    &#125;,
    <span class="hljs-comment">// la fonction de rappel va être appelée immédiatement après le début de l'observation</span>
    d: &#123;
      <span class="hljs-attr">handler</span>: <span class="hljs-string">'uneMéthode'</span>,
      <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>
    &#125;,
    <span class="hljs-attr">e</span>: [
      <span class="hljs-string">'handle1'</span>,
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle2</span> (<span class="hljs-params">valeur, ancienneValeur</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;,
      &#123;
        <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle3</span> (<span class="hljs-params">valeur, ancienneValeur</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;,
        <span class="hljs-comment">/* ... */</span>
      &#125;
    ],
    <span class="hljs-comment">// observe la valeur de `vm.e.f` : `&#123;g: 5&#125;`</span>
    <span class="hljs-string">'e.f'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">valeur, ancienneValeur</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;
  &#125;
&#125;)
vm.a = <span class="hljs-number">2</span> <span class="hljs-comment">// =&gt; nouveau : 2, ancien : 1</span></code></pre>
<p class="tip">Notez que <strong>vous ne devriez pas utiliser de fonctions fléchées pour définir un observateur</strong> (exemple: <code>saisie: nouvelleValeur =&gt; this.actualiserSuggestions(nouvelleValeur)</code>). La raison est que les fonctions fléchées sont liées au contexte parent, donc <code>this</code> ne correspondra pas à l’instance de Vue et <code>this.actualiserSuggestions</code> vaudra <code>undefined</code>.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="#vm-watch">Méthodes et données d’instance - vm.$watch</a></p>
</li>
</ul>
<h2 id="Options-DOM"><a href="#Options-DOM" class="headerlink" title="Options / DOM"></a>Options / DOM</h2><h3 id="el"><a href="#el" class="headerlink" title="el"></a>el</h3><ul>
<li><p><strong>Type :</strong> <code>string | Element</code></p>
</li>
<li><p><strong>Restriction :</strong> uniquement respecté quand l’instance est créée via <code>new</code>.</p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Fournit à l’instance de Vue un élément existant du DOM sur lequel se monter. Cela peut être une <code>String</code> représentant un sélecteur CSS ou une référence à un <code>HTMLElement</code>.</p>
<p>Une fois l’instance montée, l’élément correspondant sera accessible via <code>vm.$el</code>.</p>
<p>Si cette option est disponible à l’instanciation, l’instance sera immédiatement compilée; sinon, l’utilisateur devra explicitement appeler <code>vm.$mount()</code> pour démarrer manuellement la compilation.</p>
<p class="tip">L’élément fourni sert seulement de point de montage. Contrairement à Vue 1.x, l’élément monté sera remplacé par le DOM généré par Vue dans tous les cas. C’est pourquoi il n’est pas recommandé de monter l’instance racine sur <code>&lt;html&gt;</code> ou <code>&lt;body&gt;</code>.</p>

<p class="tip">Si ni la fonction <code>render</code> ni l’option <code>template</code> ne sont présentes, le code HTML de l’élément du DOM sur lequel le composant est monté sera extrait et défini comme template de ce composant. Dans ce cas, la version “Runtime + Compilateur” de Vue doit être utilisée.</p>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="../guide/instance.html#Diagramme-du-cycle-de-vie">Diagramme du cycle de vie</a></li>
<li><a href="../guide/installation.html#Runtime-Compiler-vs-Runtime-seul">Runtime + Compiler vs. Runtime seul</a></li>
</ul>
</li>
</ul>
<h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><ul>
<li><p><strong>Type :</strong> <code>string</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Un template sous forme de chaine de caractères qui sera utilisé comme balisage HTML pour l’instance de Vue. Le template viendra <strong>remplacer</strong> l’élément monté. Tout code HTML existant à l’intérieur de l’élément monté sera ignoré, à moins que des emplacements de distribution de contenu (slots) soient présents dans le template.</p>
<p>Si la chaine de caractères commence par <code>#</code>, elle sera évaluée comme <code>querySelector</code> et le <code>innerHTML</code> de l’élément sélectionné sera utilisé comme template. Cela permet d’utiliser l’astuce du <code>&lt;script type=&quot;x-template&quot;&gt;</code> pour inclure des templates.</p>
<p class="tip">D’un point de vue sécurité, vous devriez uniquement utiliser des templates Vue auxquels vous pouvez faire confiance. N’utilisez jamais du contenu généré côté utilisateur comme template.</p>

<p class="tip">Si la fonction <code>render</code> est présente comme option de l’instance de Vue, le template sera ignoré.</p>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="../guide/instance.html#Diagramme-du-cycle-de-vie">Diagramme du cycle de vie</a></li>
<li><a href="../guide/components.html#Distribution-de-contenu-avec-des-slots">Distribution de contenu avec des slots</a></li>
</ul>
</li>
</ul>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><ul>
<li><p><strong>Type :</strong> <code>(createElement: () =&gt; VNode) =&gt; VNode</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Une alternative aux templates en chaine de caractères vous permettant d’exploiter toute la puissance programmatique de JavaScript. La fonction de rendu <code>render</code> reçoit une méthode <code>createElement</code> comme premier argument servant à créer des <code>VNode</code>s.</p>
<p>Si le composant est un composant fonctionnel, la fonction <code>render</code> recevra aussi un argument supplémentaire <code>context</code>, qui donne accès aux données contextuelles puisque les composants fonctionnels sont sans instance.</p>
<p class="tip">La fonction <code>render</code> a la priorité par rapport à la fonction de rendu compilée à partir de l’option <code>template</code>, ou par rapport au template HTML de l’élément d’ancrage dans le DOM qui est spécifié par l’option <code>el</code>.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/render-function.html">Fonctions de rendu</a></p>
</li>
</ul>
<h3 id="renderError"><a href="#renderError" class="headerlink" title="renderError"></a>renderError</h3><blockquote>
<p>Nouveau dans la 2.2.0+</p>
</blockquote>
<ul>
<li><p><strong>Type :</strong> <code>(createElement: () =&gt; VNode, error: Error) =&gt; VNode</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p><strong>Fonctionne uniquement en mode développement.</strong></p>
<p>Fournit un rendu alternatif en sortie quand la fonction <code>render</code> par défaut rencontre une erreur. L’erreur sera passée à <code>renderError</code> comme second argument. C’est particulièrement appréciable quand utilisé conjointement avec du rechargement à chaud (hot-reload).</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  render (h) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oups'</span>)
  &#125;,
  renderError (h, err) &#123;
    <span class="hljs-keyword">return</span> h(<span class="hljs-string">'pre'</span>, &#123; <span class="hljs-attr">style</span>: &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span> &#125;&#125;, err.stack)
  &#125;
&#125;).$mount(<span class="hljs-string">'#app'</span>)</code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/render-function.html">Fonctions de rendu</a></p>
</li>
</ul>
<h2 id="Options-Cycle-de-vie-des-hooks"><a href="#Options-Cycle-de-vie-des-hooks" class="headerlink" title="Options / Cycle de vie des hooks"></a>Options / Cycle de vie des hooks</h2><p class="tip">Tous les hooks du cycle de vie ont automatiquement leur contexte <code>this</code> rattaché à l’instance, afin que vous puissiez accéder aux données, propriétés calculées et méthodes. Cela signifie que <strong>vous ne devriez pas utiliser une fonction fléchée pour définir une méthode du cycle de vie</strong>  (p. ex. <code>created: () =&gt; this.fetchTodos()</code>). La raison est que les fonctions fléchées utilisent le contexte parent, donc <code>this</code> ne sera pas l’instance de Vue comme vous pouvez vous y attendre et <code>this.fetchTodos</code> sera <code>undefined</code>.</p>

<h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><ul>
<li><p><strong>Type :</strong> <code>Function</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Appelé de manière synchrone juste après que l’instance ait été initialisée, et avant l’observation des données et l’installation des évènements / observateurs.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/instance.html#Diagramme-du-cycle-de-vie">Diagramme du cycle de vie</a></p>
</li>
</ul>
<h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><ul>
<li><p><strong>Type :</strong> <code>Function</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Appelé de manière synchrone après que l’instance ait été créée. À ce stade, l’instance a fini de traiter les options, ce qui signifie que les éléments suivants ont été installés: observation des données, propriétés calculées, méthodes, fonctions de retour des observateurs et évènements. Cependant, la propriété <code>$el</code> n’est pas encore disponible.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/instance.html#Diagramme-du-cycle-de-vie">Diagramme du cycle de vie</a></p>
</li>
</ul>
<h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><ul>
<li><p><strong>Type :</strong> <code>Function</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Appelé juste avant que le montage commence: la fonction <code>render</code> est sur le point d’être appelée pour la première fois.</p>
<p><strong>Ce hook n’est pas appelé durant le rendu côté serveur.</strong></p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/instance.html#Diagramme-du-cycle-de-vie">Diagramme du cycle de vie</a></p>
</li>
</ul>
<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><ul>
<li><p><strong>Type :</strong> <code>Function</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Appelé juste après que l’instance ait été montée, là où <code>el</code> est remplacé par le nouvellement créé <code>vm.$el</code>. Si l’instance à la racine est montée sur un élément du document, alors <code>vm.$el</code> sera aussi dans le document quand <code>mounted</code> est appelé.</p>
<p>Notez que <code>mounted</code> <strong>ne</strong> garantit <strong>pas</strong> que tous les composants aient été montés. Si vous souhaitez attendre jusqu’à ce que le rendu de la vue entière ait été fait, vous pouvez utiliser <a href="#vm-nextTick">vm.$nextTick</a> à l’intérieur de <code>mounted</code> :</p>
<pre><code class="hljs js">mounted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// Ce code va être exécuté seulement</span>
    <span class="hljs-comment">// une fois le rendu de la vue entière terminé</span>
  &#125;)
&#125;</code></pre>
<p><strong>Ce hook n’est pas appelé durant le rendu côté serveur.</strong></p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/instance.html#Diagramme-du-cycle-de-vie">Diagramme du cycle de vie</a></p>
</li>
</ul>
<h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><ul>
<li><p><strong>Type :</strong> <code>Function</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Appelé quand les données changent, avant le patch du DOM virtuel. C’est le bon endroit pour accéder au DOM existant avant la mise à jour, par ex. pour retirer manuellement des écouteurs d’évènement.</p>
<p><strong>Ce hook n’est pas appelé durant le rendu côté serveur car seul le rendu initial est généré côté serveur.</strong></p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/instance.html#Diagramme-du-cycle-de-vie">Diagramme du cycle de vie</a></p>
</li>
</ul>
<h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><ul>
<li><p><strong>Type :</strong> <code>Function</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Appelé après qu’un changement d’une donnée ait causé un nouveau rendu et patch du DOM virtuel.</p>
<p>Le DOM du composant aura été mis à jour quand ce hook est appelé, donc vous pouvez effectuer des opérations dépendantes du DOM ici. Cependant, dans la plupart des cas, vous devriez éviter de changer l’état dans ce hook. Pour réagir à des changements d’état, il vaut généralement mieux utiliser une <a href="#computed">propriété calculée</a> ou un <a href="#watch">observateur</a> à la place.</p>
<p>Notez que <code>updated</code> <strong>ne</strong> garantit <strong>pas</strong> que tous les composants aient été montés. Si vous souhaitez attendre jusqu’à ce que le rendu de la vue entière ait été fait, vous pouvez utiliser <a href="#vm-nextTick">vm.$nextTick</a> à l’intérieur de <code>updated</code> :</p>
<pre><code class="hljs js">updated: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// Ce code va être exécuté seulement</span>
    <span class="hljs-comment">// une fois le rendu de la vue entière terminé</span>
  &#125;)
&#125;</code></pre>
<p><strong>Ce hook n’est pas appelé durant le rendu côté serveur.</strong></p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/instance.html#Diagramme-du-cycle-de-vie">Diagramme du cycle de vie</a></p>
</li>
</ul>
<h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h3><ul>
<li><p><strong>Type :</strong> <code>Function</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Appelé quand un composant gardé en vie (<code>keep-alive</code>) est activé.</p>
<p><strong>Ce hook n’est pas appelé durant le rendu côté serveur.</strong></p>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="#keep-alive">Composants intégrés par défaut - keep-alive</a></li>
<li><a href="../guide/components.html#keep-alive">Composants dynamiques - keep-alive</a></li>
</ul>
</li>
</ul>
<h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h3><ul>
<li><p><strong>Type :</strong> <code>Function</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Appelé quand un composant gardé en vie (<code>keep-alive</code>) est désactivé.</p>
<p><strong>Ce hook n’est pas appelé durant le rendu côté serveur.</strong></p>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="#keep-alive">Composants intégrés par défaut - keep-alive</a></li>
<li><a href="../guide/components.html#keep-alive">Composants dynamiques - keep-alive</a></li>
</ul>
</li>
</ul>
<h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><ul>
<li><p><strong>Type :</strong> <code>Function</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Appelé juste avant qu’une instance de Vue ne soit détruite. À ce stade, l’instance est toujours pleinement fonctionnelle.</p>
<p><strong>Ce hook n’est pas appelé durant le rendu côté serveur.</strong></p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/instance.html#Diagramme-du-cycle-de-vie">Diagramme du cycle de vie</a></p>
</li>
</ul>
<h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><ul>
<li><p><strong>Type :</strong> <code>Function</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Appelé après qu’une instance de Vue ait été détruite. Quand ce hook est appelé, toutes les directives de l’instance de Vue ont été détachées, tous les écouteurs d’évènements ont été supprimés et toutes les instances de Vue enfants ont également été détruites.</p>
<p><strong>Ce hook n’est pas appelé durant le rendu côté serveur.</strong></p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/instance.html#Diagramme-du-cycle-de-vie">Diagramme du cycle de vie</a></p>
</li>
</ul>
<h3 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a>errorCaptured</h3><blockquote>
<p>Nouveau dans la 2.5.0+</p>
</blockquote>
<ul>
<li><p><strong>Type :</strong> <code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Appelé quand une erreur provenant de n’importe quel composant enfant est capturée. Le hook reçoit trois arguments : l’erreur, l’instance du composant qui a déclenché l’erreur et une chaine de caractères contenant des informations sur l’endroit où l’erreur a été capturée. Le hook peut retourner <code>false</code> pour arrêter la propagation de l’erreur.</p>
<p class="tip">Vous pouvez modifier l’état du composant dans ce hook. Il est cependant important d’avoir une condition dans votre template ou fonction de rendu qui court-circuite les autres composants quand une erreur est capturée. Autrement le composant va partir dans une boucle de rendu infinie.</p>

<p><strong>Règles de propagation d’erreur</strong></p>
<ul>
<li><p>Par défaut, toutes les erreurs sont toujours envoyées à l’objet global <code>config.errorHandler</code> s’il est défini. Donc ces erreurs peuvent toujours être reportées à un service d’analyse centralisé.</p>
</li>
<li><p>Si des hooks <code>errorCaptured</code> multiples existent sur une chaine de composant hérité ou sur une chaine parente, toutes seront invoquées avec la même erreur.</p>
</li>
<li><p>Si le hook <code>errorCaptured</code> renvoie lui-même une erreur, l’erreur originalement capturée et l’erreur courante seront toutes deux envoyées au <code>config.errorHandler</code> global.</p>
</li>
<li><p>Un hook <code>errorCaptured</code> peut retourner <code>false</code> pour empêcher la propagation de l’erreur vers le haut. Il est essentiel d’indiquer que « cette erreur a été traitée et doit être ignorée ». Cela empèchera n’importe quel hook <code>errorCaptured</code> supplémentaire ou le <code>config.errorHandler</code> d’être invoqué par cette erreur.</p>
</li>
</ul>
</li>
</ul>
<h2 id="Options-Ressources"><a href="#Options-Ressources" class="headerlink" title="Options / Ressources"></a>Options / Ressources</h2><h3 id="directives"><a href="#directives" class="headerlink" title="directives"></a>directives</h3><ul>
<li><p><strong>Type :</strong> <code>Object</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Un objet de mappage des directives à mettre à disposition de l’instance de Vue.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/custom-directive.html">Directives personnalisées</a></p>
</li>
</ul>
<h3 id="filters"><a href="#filters" class="headerlink" title="filters"></a>filters</h3><ul>
<li><p><strong>Type :</strong> <code>Object</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Un objet de mappage des filtres à mettre à disposition de l’instance de Vue.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="#Vue-filter"><code>Vue.filter</code></a></p>
</li>
</ul>
<h3 id="components"><a href="#components" class="headerlink" title="components"></a>components</h3><ul>
<li><p><strong>Type :</strong> <code>Object</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Un objet de mappage des composants à mettre à disposition de l’instance de Vue.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/components.html">Composants</a></p>
</li>
</ul>
<h2 id="Options-Divers"><a href="#Options-Divers" class="headerlink" title="Options / Divers"></a>Options / Divers</h2><h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><ul>
<li><p><strong>Type :</strong> <code>Instance de Vue</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Spécifie l’instance parente pour l’instance qui va être créée. Établit une relation parent-enfant entre les deux. Le parent sera accessible via <code>this.$parent</code> pour l’enfant, et l’enfant sera ajouté à la liste <code>$children</code> du parent.</p>
<p class="tip">Utilisez <code>$parent</code> et <code>$children</code> avec parcimonie - ils servent surtout comme écoutille de secours. Préférez l’utilisation de propriétés et d’évènements pour la communication parent-enfant.</p>

</li>
</ul>
<h3 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h3><ul>
<li><p><strong>Type :</strong> <code>Array&lt;Object&gt;</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>L’option <code>mixins</code> accepte une liste d’objets mixin. Ces objets mixin peuvent contenir des options d’instance tout comme des objets d’instance normaux, et elles seront fusionnées avec les éventuelles options existantes en utilisant la même stratégie de fusion que dans <code>Vue.extend()</code>. Par exemple, si votre mixin contient un hook <code>created</code> et que le composant lui-même en a également un, les deux fonctions seront appelées.</p>
<p>Les hooks de <em>mixin</em> sont appelés dans l’ordre dans lequel ils sont fournis, et appelés avant les propres hooks du composant.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mixin = &#123;
  <span class="hljs-attr">created</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) &#125;
&#125;
<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">created</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>) &#125;,
  <span class="hljs-attr">mixins</span>: [mixin]
&#125;)
<span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-comment">// =&gt; 2</span></code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/mixins.html">Mixins</a></p>
</li>
</ul>
<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><ul>
<li><p><strong>Type :</strong> <code>Object | Function</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Permet d’étendre déclarativement un autre composant (qui peut être un simple objet d’options ou un constructeur) sans avoir à utiliser <code>Vue.extend</code>. C’est destiné en premier lieu à rendre plus facile les extensions entre composants monofichiers.</p>
<p>Cette option est similaire à <code>mixins</code>.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> CompA = &#123; ... &#125;

<span class="hljs-comment">// étend `CompA` sans avoir à appeler `Vue.extend` sur l'un ou l'autre</span>
<span class="hljs-keyword">var</span> CompB = &#123;
  <span class="hljs-attr">extends</span>: CompA,
  ...
&#125;</code></pre>
</li>
</ul>
<h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a>provide / inject</h3><blockquote>
<p>Nouveau dans la 2.2.0+</p>
</blockquote>
<ul>
<li><p><strong>Type :</strong></p>
<ul>
<li><strong>provide :</strong> <code>Object | () =&gt; Object</code></li>
<li><strong>inject :</strong> <code>Array&lt;string&gt; | { [key: string]: string | Symbol | Object }</code></li>
</ul>
</li>
<li><p><strong>Détails :</strong></p>
<p class="tip"><code>provide</code> et <code>inject</code> sont fournis principalement pour des cas d’utilisation avancés dans les bibliothèques de plugins / composants. Il n’est PAS recommandé de les utiliser dans du code applicatif générique.</p>

<p>Ces deux options sont utilisées ensemble pour permettre à un composant parent de servir d’injecteur de dépendances pour tous ses descendants, peu importe la profondeur de la hiérarchie de composants, tant qu’ils sont dans la même chaine parente. Si vous êtes familiers avec React, c’est très similaire à la fonctionnalité de contexte dans React.</p>
<p>L’option <code>provide</code> doit être un objet ou une fonction retournant un objet. Cet objet contient les propriétés qui sont disponibles pour l’injection dans ses descendants. Vous pouvez utiliser des <code>Symbol</code> ES2015 comme clés dans cet objet, mais seulement dans les environnements supportant nativement <code>Symbol</code> et <code>Reflect.ownKeys</code>.</p>
<p>L’option <code>inject</code> doit être soit :</p>
<ul>
<li>un <code>Array</code> de <code>String</code>, ou</li>
<li>un objet où les clés sont les noms des liaisons locales et où les valeurs sont :<ul>
<li>les clés (<code>String</code> ou <code>Symbol</code>) à rechercher dans les injections disponibles, ou</li>
<li>un objet où :<ul>
<li>la propriété <code>from</code> est la clé (<code>String</code> ou <code>Symbol</code>) à rechercher dans les injections disponibles, et</li>
<li>la propriété <code>default</code> est utilisé comme valeur de substitution.</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note : les liaisons <code>provide</code> et <code>inject</code> ne sont PAS réactives. C’est intentionnel. Cependant, si vous passez un objet observé, les propriétés sur cet objet resteront réactives.</p>
</blockquote>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// parent component providing 'foo'</span>
<span class="hljs-keyword">var</span> Provider = &#123;
  <span class="hljs-attr">provide</span>: &#123;
    <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>
  &#125;,
  <span class="hljs-comment">// ...</span>
&#125;

<span class="hljs-comment">// le composant enfant injectant 'foo'</span>
<span class="hljs-keyword">var</span> Enfant = &#123;
  <span class="hljs-attr">inject</span>: [<span class="hljs-string">'foo'</span>],
  created () &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.foo) <span class="hljs-comment">// =&gt; "bar"</span>
  &#125;
  <span class="hljs-comment">// ...</span>
&#125;</code></pre>
<p>Avec les <code>Symbol</code> ES2015, la fonction <code>provide</code> et l’objet <code>inject</code> :</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-built_in">Symbol</span>()

<span class="hljs-keyword">const</span> Provider = &#123;
  provide () &#123;
    <span class="hljs-keyword">return</span> &#123;
      [s]: <span class="hljs-string">'foo'</span>
    &#125;
  &#125;
&#125;

<span class="hljs-keyword">const</span> Enfant = &#123;
  <span class="hljs-attr">inject</span>: &#123; s &#125;,
  <span class="hljs-comment">// ...</span>
&#125;</code></pre>
<blockquote>
<p>Les deux prochains exemples fonctionnent seulement avec Vue 2.2.1+. En dessous de cette version, les valeurs injectées étaient résolues après l’initialisation des <code>props</code> et de <code>data</code>.</p>
</blockquote>
<p>En utilisant une valeur injectée comme valeur par défaut pour une prop :</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> Enfant = &#123;
  <span class="hljs-attr">inject</span>: [<span class="hljs-string">'foo'</span>],
  <span class="hljs-attr">props</span>: &#123;
    <span class="hljs-attr">bar</span>: &#123;
      <span class="hljs-keyword">default</span> () &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo
      &#125;
    &#125;
  &#125;
&#125;</code></pre>
<p>En utilisant une valeur injectée comme entrée de données :</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> Enfant = &#123;
  <span class="hljs-attr">inject</span>: [<span class="hljs-string">'foo'</span>],
  data () &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">bar</span>: <span class="hljs-keyword">this</span>.foo
    &#125;
  &#125;
&#125;</code></pre>
<blockquote>
<p>Dans la 2.5.0+ les injections peuvent être optionnelles avec une valeur par défaut :</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> Child = &#123;
  <span class="hljs-attr">inject</span>: &#123;
    <span class="hljs-attr">foo</span>: &#123; <span class="hljs-attr">default</span>: <span class="hljs-string">'foo'</span> &#125;
  &#125;
&#125;</code></pre>
<p>S’il est nécessaire de de pouvoir injecter via une propriété avec un nom différent, utilisez <code>from</code> pour indiquer la source de la propriété :</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> Child = &#123;
  <span class="hljs-attr">inject</span>: &#123;
    <span class="hljs-attr">foo</span>: &#123;
      <span class="hljs-attr">from</span>: <span class="hljs-string">'bar'</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-string">'foo'</span>
    &#125;
  &#125;
&#125;</code></pre>
<p>De façon similaire aux valeurs par défaut des props, vous devez utiliser une fabrique de fonctions pour les valeurs non primitives :</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> Child = &#123;
  <span class="hljs-attr">inject</span>: &#123;
    <span class="hljs-attr">foo</span>: &#123;
      <span class="hljs-attr">from</span>: <span class="hljs-string">'bar'</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
    &#125;
  &#125;
&#125;</code></pre>
</li>
</ul>
<h2 id="Options-Divers-1"><a href="#Options-Divers-1" class="headerlink" title="Options / Divers"></a>Options / Divers</h2><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><ul>
<li><p><strong>Type :</strong> <code>string</code></p>
</li>
<li><p><strong>Restriction :</strong> respecté uniquement lorsqu’utilisé comme option du composant.</p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Permet au composant de s’invoquer lui-même récursivement dans son template. Notez que lorsqu’un composant est déclaré globalement avec <code>Vue.component()</code>, l’identifiant global est automatiquement assigné à sa propriété <code>name</code>.</p>
<p>Un autre bénéfice du fait de spécifier une option <code>name</code> est le débogage. Les composants nommés donnent des messages d’avertissement plus utiles. De plus, lorsque vous inspectez une application via les <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener">vue-devtools</a>, les composants non nommés s’afficheront en tant que <code>&lt;AnonymousComponent&gt;</code>, ce qui n’est pas très instructif. En fournissant une option <code>name</code>, vous obtiendrez bien plus d’informations dans l’arbre de composants.</p>
</li>
</ul>
<h3 id="delimiters"><a href="#delimiters" class="headerlink" title="delimiters"></a>delimiters</h3><ul>
<li><p><strong>Type :</strong> <code>Array&lt;string&gt;</code></p>
</li>
<li><p><strong>Par défaut :</strong> <code>["{{", "}}"]</code></p>
</li>
<li><p><strong>Restrictions :</strong> Cette option n’est disponible que dans la version complète du build, avec la compilation dans le navigateur.</p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Change les délimiteurs d’interpolation de texte. <strong>Cette option est uniquement disponible en version complète.</strong></p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">delimiters</span>: [<span class="hljs-string">'$&#123;'</span>, <span class="hljs-string">'&#125;'</span>]
&#125;)

<span class="hljs-comment">// Les délimiteurs ont été changés pour suivre le style des templates ES6</span></code></pre>
</li>
</ul>
<h3 id="functional"><a href="#functional" class="headerlink" title="functional"></a>functional</h3><ul>
<li><p><strong>Type :</strong> <code>Boolean</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Rend le composant sans état (pas de propriété <code>data</code>) et sans instance (pas de contexte <code>this</code>). Il s’agit simplement d’une fonction <code>render</code> qui retourne des nœuds virtuels, ce qui réduit fortement les couts en performance au rendu pour ce type de composants.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/render-function.html#Composants-fonctionnels">Composants fonctionnels</a></p>
</li>
</ul>
<h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><blockquote>
<p>Nouveau dans la 2.2.0</p>
</blockquote>
<ul>
<li><p><strong>Type :</strong> <code>{ prop?: string, event?: string }</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Permet à un composant personnalisé de définir la prop et l’évènement utilisé quand il est utilisé avec <code>v-model</code>. Par défaut, <code>v-model</code> sur un composant utilise <code>value</code> comme prop et <code>input</code> comme évènement, mais certains types de champs de saisie comme les cases à cocher et les boutons radio peuvent vouloir utiliser la prop <code>value</code> à d’autres fins. Utiliser l’option <code>model</code> peut éviter le conflit dans ce genre de cas.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js">Vue.component(<span class="hljs-string">'ma-checkbox'</span>, &#123;
  <span class="hljs-attr">model</span>: &#123;
    <span class="hljs-attr">prop</span>: <span class="hljs-string">'checked'</span>,
    <span class="hljs-attr">event</span>: <span class="hljs-string">'change'</span>
  &#125;,
  <span class="hljs-attr">props</span>: &#123;
    <span class="hljs-comment">// cela permet d'utiliser la prop `value` à d'autres fins</span>
    value: <span class="hljs-built_in">String</span>,
    <span class="hljs-comment">// utilise `checked` comme prop qui prend la place de `value`</span>
    checked: &#123;
      <span class="hljs-attr">type</span> : <span class="hljs-built_in">Number</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>
    &#125;
  &#125;,
  <span class="hljs-comment">// ...</span>
&#125;)</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ma-checkbox</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"foo"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"une certaine valeur"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ma-checkbox</span>&gt;</span></code></pre>
<p>Le code ci-dessus est équivalent à :</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ma-checkbox</span>
  <span class="hljs-attr">:checked</span>=<span class="hljs-string">"foo"</span>
  @<span class="hljs-attr">change</span>=<span class="hljs-string">"val =&gt; &#123; foo = val &#125;"</span>
  <span class="hljs-attr">value</span>=<span class="hljs-string">"une certaine valeur"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ma-checkbox</span>&gt;</span></code></pre>
</li>
</ul>
<h3 id="inheritAttrs"><a href="#inheritAttrs" class="headerlink" title="inheritAttrs"></a>inheritAttrs</h3><blockquote>
<p>Nouveau dans la 2.4.0+</p>
</blockquote>
<ul>
<li><p><strong>Type :</strong> <code>boolean</code></p>
</li>
<li><p><strong>Par défaut :</strong> <code>true</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Par défaut, les attributs de portée parente qui ne sont pas reconnus en tant que props vont « échouer » et être appliqués à l’élément racine du composant enfant en tant qu’attribut HTML normal. Quand on crée un composant qui encapsule un élément cible ou un autre composant, cela peut ne pas être le comportement souhaité. En mettant <code>inheritAttrs</code> à <code>false</code>, ce comportement par défaut peut être désactivé. Les attributs sont disponibles via la propriété d’instance <code>$attrs</code> (aussi nouvelle en 2.4) et peuvent être explicitement liée a un élément non-racine en utilisant <code>v-bind</code>.</p>
<p>Note : cette option n’affecte <strong>pas</strong> les liaisons <code>class</code> et <code>style</code>.</p>
</li>
</ul>
<h3 id="comments"><a href="#comments" class="headerlink" title="comments"></a>comments</h3><blockquote>
<p>Nouveau dans la 2.4.0+</p>
</blockquote>
<ul>
<li><p><strong>Type :</strong> <code>boolean</code></p>
</li>
<li><p><strong>Par défaut :</strong> <code>false</code></p>
</li>
<li><p><strong>Restrictions :</strong> Cette option est uniquement disponible dans le build complet, avec la compilation dans le navigateur.</p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Quand mis à <code>true</code>, cela va conserver et faire le rendu HTML des commentaires trouvés dans les templates. Le comportement par défaut est de les enlever.</p>
</li>
</ul>
<h2 id="Proprietes-d’instance"><a href="#Proprietes-d’instance" class="headerlink" title="Propriétés d’instance"></a>Propriétés d’instance</h2><h3 id="vm-data"><a href="#vm-data" class="headerlink" title="vm.$data"></a>vm.$data</h3><ul>
<li><p><strong>Type :</strong> <code>Object</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>L’objet <code>data</code> est ce que l’instance de Vue observe. L’instance de Vue agit comme un proxy pour l’accès aux propriétés de cet objet <code>data</code>.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="#data">Options / Data - data</a></p>
</li>
</ul>
<h3 id="vm-props"><a href="#vm-props" class="headerlink" title="vm.$props"></a>vm.$props</h3><blockquote>
<p>Nouveau dans la 2.2.0+</p>
</blockquote>
<ul>
<li><p><strong>Type :</strong> <code>Object</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Un objet représentant les props actuelles qu’un composant a reçues. L’instance de Vue agit comme un proxy pour accéder aux propriétés sur son objet <code>props</code>.</p>
</li>
</ul>
<h3 id="vm-el"><a href="#vm-el" class="headerlink" title="vm.$el"></a>vm.$el</h3><ul>
<li><p><strong>Type :</strong> <code>Element</code></p>
</li>
<li><p><strong>Accessible uniquement en lecture</strong></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>L’élément racine du DOM que gère l’instance de Vue.</p>
</li>
</ul>
<h3 id="vm-options"><a href="#vm-options" class="headerlink" title="vm.$options"></a>vm.$options</h3><ul>
<li><p><strong>Type :</strong> <code>Object</code></p>
</li>
<li><p><strong>Accessible uniquement en lecture</strong></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Les options d’instanciation utilisées pour cette instance de Vue. C’est utile lorsque vous voulez inclure des propriétés personnalisées dans les options:</p>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  optionPersonnalisée: <span class="hljs-string">'foo'</span>,
  <span class="hljs-attr">created</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.$options.optionPersonnalisée) <span class="hljs-comment">// =&gt; 'foo'</span>
  &#125;
&#125;)</code></pre>
</li>
</ul>
<h3 id="vm-parent"><a href="#vm-parent" class="headerlink" title="vm.$parent"></a>vm.$parent</h3><ul>
<li><p><strong>Type :</strong> <code>Instance de Vue</code></p>
</li>
<li><p><strong>Accessible uniquement en lecture</strong></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>L’instance parente, si l’instance actuelle en a une.</p>
</li>
</ul>
<h3 id="vm-root"><a href="#vm-root" class="headerlink" title="vm.$root"></a>vm.$root</h3><ul>
<li><p><strong>Type :</strong> <code>Instance de Vue</code></p>
</li>
<li><p><strong>Accessible uniquement en lecture</strong></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>L’instance de Vue à la racine de l’arbre de composants actuel. Si l’instance actuelle n’a pas de parents, la valeur sera l’instance elle-même.</p>
</li>
</ul>
<h3 id="vm-children"><a href="#vm-children" class="headerlink" title="vm.$children"></a>vm.$children</h3><ul>
<li><p><strong>Type :</strong> <code>Array&lt;Instance de Vue&gt;</code></p>
</li>
<li><p><strong>Accessible uniquement en lecture</strong></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Les composants enfants directs de l’instance actuelle. <strong>Notez que l’ordre des enfants n’est pas garanti pour <code>$children</code>, et que cette propriété n’est pas réactive.</strong> Si vous vous retrouvez à essayer d’utiliser <code>$children</code> pour de la liaison de données, optez plutôt pour un <code>Array</code> et <code>v-for</code> pour générer les composants enfants, en utilisant l’<code>Array</code> comme unique source fiable.</p>
</li>
</ul>
<h3 id="vm-slots"><a href="#vm-slots" class="headerlink" title="vm.$slots"></a>vm.$slots</h3><ul>
<li><p><strong>Type :</strong> <code>{ [name: string]: ?Array&lt;VNode&gt; }</code></p>
</li>
<li><p><strong>Accessible uniquement en lecture</strong></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Utilisé pour accéder programmatiquement à du contenu <a href="../guide/components.html#Distribution-de-contenu-avec-des-slots">distribué par slots</a>. Chaque <a href="../guide/components.html#Slots-nommes">slot nommé</a> a sa propriété correspondante (p. ex. le contenu de <code>v-slot:foo</code> sera trouvé dans <code>vm.$slots.foo</code>). La propriété <code>default</code> contient tous les nœuds non inclus dans un slot nommé ou contenus de <code>v-slot:default</code>.</p>
<p><strong>Note:</strong> <code>v-slot:foo</code> est supporté dans la v2.6+. Pour des versions plus anciennes, vous pouvez utiliser la <a href="../guide/components-slots.html#Deprecated-Syntax">syntaxe dépréciée</a>.</p>
<p>Accéder à <code>vm.$slots</code> est plus utile lorsque vous écrivez un composant avec une <a href="../guide/render-function.html">fonction de rendu</a>.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>À propos de moi<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Voici du contenu pour la page, qui sera inclus dans vm.$slots.default, car il n'est pas à l'intérieur d'un slot nommé.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Copyright 2016 Evan You<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Si j'ai du contenu ici, il sera aussi inclus dans vm.$slots.default.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span></code></pre>
<pre><code class="hljs js">Vue.component(<span class="hljs-string">'blog-post'</span>, &#123;
  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) </span>&#123;
    <span class="hljs-keyword">var</span> header = <span class="hljs-keyword">this</span>.$slots.header
    <span class="hljs-keyword">var</span> body   = <span class="hljs-keyword">this</span>.$slots.default
    <span class="hljs-keyword">var</span> footer = <span class="hljs-keyword">this</span>.$slots.footer
    <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">'div'</span>, [
      createElement(<span class="hljs-string">'header'</span>, header),
      createElement(<span class="hljs-string">'main'</span>, body),
      createElement(<span class="hljs-string">'footer'</span>, footer)
    ])
  &#125;
&#125;)</code></pre>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="#slot">Composant <code>&lt;slot&gt;</code></a></li>
<li><a href="../guide/components.html#Distribution-de-contenu-avec-des-slots">Distribution de contenu avec des slots</a></li>
<li><a href="../guide/render-function.html#Slots">Fonctions de rendu - Slots</a></li>
</ul>
</li>
</ul>
<h3 id="vm-scopedSlots"><a href="#vm-scopedSlots" class="headerlink" title="vm.$scopedSlots"></a>vm.$scopedSlots</h3><blockquote>
<p>Nouveau dans la 2.1.0+</p>
</blockquote>
<ul>
<li><p><strong>Type :</strong> <code>{ [name: string]: props =&gt; Array&lt;VNode&gt; | undefined }</code></p>
</li>
<li><p><strong>Accessible uniquement en lecture</strong></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Utilisé pour accéder programmatiquement aux <a href="../guide/components.html#Slots-avec-portee">slots avec portée</a>. Pour chaque slot, y compris celui par défaut <code>default</code>, l’objet contient une fonction correspondante qui retourne des nœuds virtuels <code>VNode</code>.</p>
<p>Accéder à <code>vm.$scopedSlots</code> est surtout utile lors de l’écriture d’un composant avec une <a href="../guide/render-function.html">fonction de rendu</a>.</p>
<p><strong>Note :</strong> depuis la 2.6.0+, il y a deux changements notables pour cette propriété :</p>
<ol>
<li><p>Les fonctions de slot avec portée garantissent de retourner un tableau de VNodes, sauf si la valeur de retour est invalide, auquel cas la fonction retournera <code>undefined</code>.</p>
</li>
<li><p>Tous les <code>$slots</code> sont maintenant exposés via <code>$scopedSlots</code> en tant que fonctions. Si vous travaillez avec des fonctions de rendu, il est maintenant recommandé de toujours accéder aux slots via <code>$scopedSlots</code>, si elles utilisent actuellement une portée ou non. Cela ne va pas seulement permettre d’ajouter des scopes simplement lors de futures refactorisations, mais également de faciliter votre éventuelle migration vers Vue 3, où tous les slots seront des fonctions.</p>
</li>
</ol>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="#slot">Composant <code>&lt;slot&gt;</code></a></li>
<li><a href="../guide/components.html#Slots-avec-portee">Slots avec portée</a></li>
<li><a href="../guide/render-function.html#Slots">Fonctions de rendu - Slots</a></li>
</ul>
</li>
</ul>
<h3 id="vm-refs"><a href="#vm-refs" class="headerlink" title="vm.$refs"></a>vm.$refs</h3><ul>
<li><p><strong>Type :</strong> <code>Object</code></p>
</li>
<li><p><strong>Accessible uniquement en lecture</strong></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Un objet contenant des éléments du DOM et des composants, ayant des <a href="#ref">attributs <code>ref</code></a> enregistrée.</p>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="../guide/components.html#Les-refs-des-composants-enfants">Les refs des composants enfants</a></li>
<li><a href="#ref">Attributs spéciaux - ref</a></li>
</ul>
</li>
</ul>
<h3 id="vm-isServer"><a href="#vm-isServer" class="headerlink" title="vm.$isServer"></a>vm.$isServer</h3><ul>
<li><p><strong>Type :</strong> <code>boolean</code></p>
</li>
<li><p><strong>Accessible uniquement en lecture</strong></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Vaut <code>true</code> si l’instance actuelle de Vue s’exécute côté serveur.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/ssr.html">Rendu côté serveur</a></p>
</li>
</ul>
<h3 id="vm-attrs"><a href="#vm-attrs" class="headerlink" title="vm.$attrs"></a>vm.$attrs</h3><blockquote>
<p>Nouveau dans la 2.4.0+</p>
</blockquote>
<ul>
<li><p><strong>Type :</strong> <code>{ [key: string]: string }</code></p>
</li>
<li><p><strong>Accessible uniquement en lecture</strong></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Contient les attributs liés de portée parente (à l’exception de <code>class</code> et <code>style</code>) qui ne sont pas reconnus (et extrait) en tant que props. Quand un composant n’a aucune props de déclarée, il contient essentiellement toutes les liaisons de portée parente (à l’exception de <code>class</code> et <code>style</code>), et peut être passé à l’intérieur d’un composant enfant via <code>v-bind=&quot;$attrs&quot;</code>. Ceci est utile pour la création de composants d’ordre supérieur.</p>
</li>
</ul>
<h3 id="vm-listeners"><a href="#vm-listeners" class="headerlink" title="vm.$listeners"></a>vm.$listeners</h3><blockquote>
<p>Nouveau dans la 2.4.0+</p>
</blockquote>
<ul>
<li><p><strong>Type :</strong> <code>{ [key: string]: Function | Array&lt;Function&gt; }</code></p>
</li>
<li><p><strong>Accessible uniquement en lecture</strong></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Contient le gestionnaire d’évènement <code>v-on</code> de portée parente (sans le modificateur <code>.native</code>). Il peut être passé à l’intérieur d’un composant enfant via <code>v-on=&quot;$listeners&quot;</code>. Ceci est utile pour la création de composants d’ordre supérieur.</p>
</li>
</ul>
<h2 id="Methodes-et-donnees-d’instance"><a href="#Methodes-et-donnees-d’instance" class="headerlink" title="Méthodes et données d’instance"></a>Méthodes et données d’instance</h2><h3 id="vm-watch-expOuFn-callback-options"><a href="#vm-watch-expOuFn-callback-options" class="headerlink" title="vm.$watch( expOuFn, callback, [options] )"></a>vm.$watch( expOuFn, callback, [options] )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{string | Function} expOrFn</code></li>
<li><code>{Function | Object} callback</code></li>
<li><code>{Object} [options]</code><ul>
<li><code>{boolean} deep</code></li>
<li><code>{boolean} immediate</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Retourne :</strong> <code>{Function} unwatch</code></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Observe les changements sur l’instance de Vue à partir d’une expression ou d’une fonction calculée. La fonction de rappel est appelée avec la nouvelle et l’ancienne valeur. L’expression accepte uniquement les chemins simples délimités par des points. Pour des expressions plus complexes, utilisez plutôt une fonction.</p>
</li>
</ul>
<p class="tip">Note: lors de la modification (et non la réassignation) d’un <code>Object</code> ou d’un <code>Array</code>, l’ancienne valeur sera la même que la nouvelle valeur car ils référencient le même <code>Object</code>/<code>Array</code>. Vue ne conserve pas de copie de la valeur avant modification.</p>

<ul>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// keypath</span>
vm.$watch(<span class="hljs-string">'a.b.c'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nouvelleValeur, ancienneValeur</span>) </span>&#123;
  <span class="hljs-comment">// fait quelque-chose</span>
&#125;)

<span class="hljs-comment">// fonction</span>
vm.$watch(
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// everytime the expression `this.a + this.b` yields a different result,</span>
    <span class="hljs-comment">// the handler will be called. It's as if we were watching a computed</span>
    <span class="hljs-comment">// property without defining the computed property itself</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a + <span class="hljs-keyword">this</span>.b
  &#125;,
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nouvelleValeur, ancienneValeur</span>) </span>&#123;
    <span class="hljs-comment">// fait quelque-chose</span>
  &#125;
)</code></pre>
<p><code>vm.$watch</code> retourne une fonction <code>unwatch</code> qui une fois exécutée stoppe le déclenchement de la fonction <code>callback</code> :</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> unwatch = vm.$watch(<span class="hljs-string">'a'</span>, cb)
<span class="hljs-comment">// plus tard, démonte l'observateur</span>
unwatch()</code></pre>
</li>
<li><p><strong>Option: deep</strong></p>
<p>Pour aussi détecter les changements des valeurs imbriquées dans les objets, vous devez passer <code>deep: true</code> dans l’argument des options. Notez que vous n’avez pas besoin de cela pour observer les modifications d’un <code>Array</code>.</p>
<pre><code class="hljs js">vm.$watch(<span class="hljs-string">'monObjet'</span>, callback, &#123;
  <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>
&#125;)
vm.monObjet.valeurImbriquée = <span class="hljs-number">123</span>
<span class="hljs-comment">// la fonction de rappel est déclenchée</span></code></pre>
</li>
<li><p><strong>Option: immediate</strong></p>
<p>Passer <code>immediate: true</code> dans les options déclenchera immédiatement la fonction <code>callback</code> avec la valeur actuelle de l’expression :</p>
<pre><code class="hljs js">vm.$watch(<span class="hljs-string">'a'</span>, callback, &#123;
  <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>
&#125;)
<span class="hljs-comment">// la fonction `callback` est immédiatement déclenchée avec la valeur actuelle de `a`</span></code></pre>
</li>
</ul>
<h3 id="vm-set-cible-nomDePropriete-index-valeur"><a href="#vm-set-cible-nomDePropriete-index-valeur" class="headerlink" title="vm.$set( cible, nomDePropriete/index, valeur )"></a>vm.$set( cible, nomDePropriete/index, valeur )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{Object | Array} cible</code></li>
<li><code>{string | number} nomDePropriete/index</code></li>
<li><code>{any} valeur</code></li>
</ul>
</li>
<li><p><strong>Retourne :</strong> la valeur assignée</p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>C’est un <strong>alias</strong> à la fonction globale <code>Vue.set</code>.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="#Vue-set">Vue.set</a></p>
</li>
</ul>
<h3 id="vm-delete-cible-nomDePropriete-index"><a href="#vm-delete-cible-nomDePropriete-index" class="headerlink" title="vm.$delete( cible, nomDePropriete/index )"></a>vm.$delete( cible, nomDePropriete/index )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{Object | Array} cible</code></li>
<li><code>{string | number} nomDePropriete/index</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>C’est un <strong>alias</strong> à la fonction globale <code>Vue.delete</code>.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="#Vue-delete">Vue.delete</a></p>
</li>
</ul>
<h2 id="Methodes-et-Evenements-d’Instance"><a href="#Methodes-et-Evenements-d’Instance" class="headerlink" title="Méthodes et Évènements d’Instance"></a>Méthodes et Évènements d’Instance</h2><h3 id="vm-on-evenement-callback"><a href="#vm-on-evenement-callback" class="headerlink" title="vm.$on( évènement, callback )"></a>vm.$on( évènement, callback )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{string | Array&lt;string&gt;} évènement</code> (<code>Array</code> supportée unique depuis la 2.2.0)</li>
<li><code>{Function} callback</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Écoute un évènement personnalisé sur l’instance <code>vm</code>. Les évènements peuvent être déclenchés avec <code>vm.$emit</code>. La fonction de rappel recevra tous les arguments additionnels passés dans ces méthodes de déclenchement d’évènement.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js">vm.$on(<span class="hljs-string">'test'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(msg)
&#125;)
vm.$emit(<span class="hljs-string">'test'</span>, <span class="hljs-string">'salut'</span>)
<span class="hljs-comment">// =&gt; "salut"</span></code></pre>
</li>
</ul>
<h3 id="vm-once-evenement-callback"><a href="#vm-once-evenement-callback" class="headerlink" title="vm.$once( évènement, callback )"></a>vm.$once( évènement, callback )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{string} évènement</code></li>
<li><code>{Function} callback</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Écoute un évènement personnalisé, mais qu’une seule fois. L’écouteur sera supprimé une fois déclenché pour la première fois.</p>
</li>
</ul>
<h3 id="vm-off-event-callback"><a href="#vm-off-event-callback" class="headerlink" title="vm.$off( [event, callback] )"></a>vm.$off( [event, callback] )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{string | Array&lt;string&gt;} évènement</code> (les tableaux sont seulement supportés dans la 2.2.2+)</li>
<li><code>{Function} [callback]</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Supprime un ou des écouteurs d’évènements.</p>
<ul>
<li><p>Si aucun argument n’est fourni, supprime tous les écouteurs d’évènements;</p>
</li>
<li><p>Si seul l’argument événément est fourni, supprime tous les écouteurs de cet évènement;</p>
</li>
<li><p>Si l’évènement et la fonction de rappel sont fournis, supprime l’écouteur uniquement pour cet événément et cette fonction de rappel spécifique.</p>
</li>
</ul>
</li>
</ul>
<h3 id="vm-emit-eventName-…args"><a href="#vm-emit-eventName-…args" class="headerlink" title="vm.$emit( eventName, […args] )"></a>vm.$emit( eventName, […args] )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{string} nom d&#39;évènement</code></li>
<li><code>[...arguments]</code></li>
</ul>
<p>Déclenche un évènement sur l’instance actuelle. Tous les arguments additionnels sont passés à la fonction de rappel de l’écouteur.</p>
</li>
<li><p><strong>Exemples:</strong></p>
<p>Utiliser <code>$emit</code> avec un nom d’évènement :</p>
<pre><code class="hljs js">Vue.component(<span class="hljs-string">'welcome-button'</span>, &#123;
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;button v-on:click="$emit('welcome')"&gt;
      Cliquez-moi pour être salué
    &lt;/button&gt;
  `</span>
&#125;)</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"emit-example-simple"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">welcome-button</span> <span class="hljs-attr">v-on:welcome</span>=<span class="hljs-string">"sayHi"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">welcome-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">el</span>: <span class="hljs-string">'#emit-example-simple'</span>,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      alert(<span class="hljs-string">'Salut !'</span>)
    &#125;
  &#125;
&#125;)</code></pre>

  <div id="emit-example-simple" class="demo">
    <welcome-button v-on:welcome="sayHi"></welcome-button>
  </div>
  <script>
    Vue.component('welcome-button', {
      template: `
        <button v-on:click="$emit('welcome')">
          Cliquez-moi pour être salué
        </button>
      `
    })
    new Vue({
      el: '#emit-example-simple',
      methods: {
        sayHi: function () {
          alert('Salut !')
        }
      }
    })
  </script>
  
<p>Utiliser <code>$emit</code> avec des arguments additionnels :</p>
<pre><code class="hljs js">Vue.component(<span class="hljs-string">'magic-eight-ball'</span>, &#123;
  <span class="hljs-attr">data</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">possibleAdvice</span>: [<span class="hljs-string">'Oui'</span>, <span class="hljs-string">'Non'</span>, <span class="hljs-string">'Peut-être'</span>]
    &#125;
  &#125;,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-attr">giveAdvice</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-keyword">var</span> randomAdviceIndex = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-keyword">this</span>.possibleAdvice.length)
      <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'give-advice'</span>, <span class="hljs-keyword">this</span>.possibleAdvice[randomAdviceIndex])
    &#125;
  &#125;,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;button v-on:click="giveAdvice"&gt;
      Cliquez-moi pour un indice
    &lt;/button&gt;
  `</span>
&#125;)</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"emit-example-argument"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">magic-eight-ball</span> <span class="hljs-attr">v-on:give-advice</span>=<span class="hljs-string">"showAdvice"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">magic-eight-ball</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">el</span>: <span class="hljs-string">'#emit-example-argument'</span>,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-attr">showAdvice</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">advice</span>) </span>&#123;
      alert(advice)
    &#125;
  &#125;
&#125;)</code></pre>

  <div id="emit-example-argument" class="demo">
    <magic-eight-ball v-on:give-advice="showAdvice"></magic-eight-ball>
  </div>
  <script>
    Vue.component('magic-eight-ball', {
      data: function () {
        return {
          possibleAdvice: ['Oui', 'Non', 'Peut-être']
        }
      },
      methods: {
        giveAdvice: function () {
          var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)
          this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])
        }
      },
      template: `
        <button v-on:click="giveAdvice">
          Cliquez-moi pour un indice
        </button>
      `
    })
    new Vue({
      el: '#emit-example-argument',
      methods: {
        showAdvice: function (advice) {
          alert(advice)
        }
      }
    })
  </script>
  
</li>
</ul>
<h2 id="Methodes-d’Instance-Cycle-de-Vie"><a href="#Methodes-d’Instance-Cycle-de-Vie" class="headerlink" title="Méthodes d’Instance / Cycle de Vie"></a>Méthodes d’Instance / Cycle de Vie</h2><h3 id="vm-mount-elementOuSelecteur"><a href="#vm-mount-elementOuSelecteur" class="headerlink" title="vm.$mount( [élémentOuSelecteur] )"></a>vm.$mount( [élémentOuSelecteur] )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{Element | string} [élémentOuSelecteur]</code></li>
<li><code>{boolean} [hydratation]</code></li>
</ul>
</li>
<li><p><strong>Retourne :</strong> <code>vm</code> - l’instance elle-même</p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Si une Instance de Vue n’a pas reçu l’option <code>el</code> à l’instanciation, il sera dans un état « non monté », sans élément du DOM associé. <code>vm.$mount()</code> peut être utilisé pour démarrer manuellement le montage d’une Instance de Vue non montée.</p>
<p>Si l’argument <code>élémentOuSelecteur</code> n’est pas fourni, le rendu du template se fera dans un élément hors du document, et vous devrez utiliser les API natives du DOM pour l’insérer vous-même dans le document.</p>
<p>La méthode retourne l’instance elle-même afin que vous puissiez chainer d’autres méthodes d’instance ensuite.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> MonComposant = Vue.extend(&#123;
  <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;Salut!&lt;/div&gt;'</span>
&#125;)

<span class="hljs-comment">// crée et monte sur #app (remplacera #app)</span>
<span class="hljs-keyword">new</span> MonComposant().$mount(<span class="hljs-string">'#app'</span>)

<span class="hljs-comment">// le code ci-dessus est l'équivalent de :</span>
<span class="hljs-keyword">new</span> MonComposant(&#123; <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span> &#125;)

<span class="hljs-comment">// ou bien, fait le rendu hors du document et l'insère par la suite</span>
<span class="hljs-keyword">var</span> composant = <span class="hljs-keyword">new</span> MonComposant().$mount()
<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'app'</span>).appendChild(composant.$el)</code></pre>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="../guide/instance.html#Diagramme-du-cycle-de-vie">Diagramme du cycle de vie</a></li>
<li><a href="../guide/ssr.html">Rendu côté serveur</a></li>
</ul>
</li>
</ul>
<h3 id="vm-forceUpdate"><a href="#vm-forceUpdate" class="headerlink" title="vm.$forceUpdate()"></a>vm.$forceUpdate()</h3><ul>
<li><p><strong>Utilisation :</strong></p>
<p>Force l’Instance de Vue à refaire son rendu. Notez que cela n’affecte pas tous les composants enfants, seulement l’instance elle-même et les composants enfants avec un contenu de slot inséré.</p>
</li>
</ul>
<h3 id="vm-nextTick-callback"><a href="#vm-nextTick-callback" class="headerlink" title="vm.$nextTick( [callback] )"></a>vm.$nextTick( [callback] )</h3><ul>
<li><p><strong>Arguments :</strong></p>
<ul>
<li><code>{Function} [callback]</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Reporte l’exécution de la fonction <code>callback</code> au prochain cycle de mise à jour du DOM. Utilisez ceci immédiatement après avoir changé des données pour attendre la mise à jour du DOM. C’est la même chose que la fonction globale <code>Vue.nextTick</code>, sauf que le contexte <code>this</code> dans la fonction <code>callback</code> est automatiquement lié à l’instance appelant cette méthode.</p>
<blockquote>
<p>Nouveau dans la 2.1.0+ : retourne une promesse si aucune fonction de rappel n’est fournie et si les promesses ne sont pas supportées dans l’environnement d’exécution. Notez que Vue ne fournit pas de polyfill aux promesses. Aussi, si vous ciblez des navigateurs qui ne supportent pas les promesses nativement (on parle de toi, IE), vous pouvez fournir un polyfill vous-même.</p>
</blockquote>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-comment">// ...</span>
  methods: &#123;
    <span class="hljs-comment">// ...</span>
    exemple: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-comment">// modifie des données</span>
      <span class="hljs-keyword">this</span>.message = <span class="hljs-string">'changé'</span>
      <span class="hljs-comment">// le DOM n'est pas encore mis à jour</span>
      <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-comment">// le DOM est maintenant à jour</span>
        <span class="hljs-comment">// `this` est lié à l'instance courante</span>
        <span class="hljs-keyword">this</span>.faireAutreChose()
      &#125;)
    &#125;
  &#125;
&#125;)</code></pre>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="#Vue-nextTick">Vue.nextTick</a></li>
<li><a href="../guide/reactivity.html#File-d’attente-de-mise-a-jour-asynchrone">File d’attente de mise à jour asynchrone</a></li>
</ul>
</li>
</ul>
<h3 id="vm-destroy"><a href="#vm-destroy" class="headerlink" title="vm.$destroy()"></a>vm.$destroy()</h3><ul>
<li><p><strong>Utilisation :</strong></p>
<p>Détruit complètement une instance de Vue <code>vm</code>. Supprime ses connexions avec d’autres instances de Vue, détache toutes ses directives, désactive tous les écouteurs d’évènements.</p>
<p>Déclenche les hooks <code>beforeDestroy</code> et <code>destroyed</code>.</p>
<p class="tip">Dans les cas d’utilisation normaux, vous ne devriez pas avoir à appeler cette méthode vous-même. Contrôlez plutôt le cycle de vie de vos composants enfants de manière pilotée par les données, en utilisant <code>v-if</code> et <code>v-for</code>.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/instance.html#Diagramme-du-cycle-de-vie">Diagramme du cycle de vie</a></p>
</li>
</ul>
<h2 id="Directives"><a href="#Directives" class="headerlink" title="Directives"></a>Directives</h2><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><ul>
<li><p><strong>Attend comme valeur :</strong> <code>string</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Met à jour le contenu textuel (<code>textContent</code>) de l’élément. Si vous n’avez besoin de mettre à jour qu’une partie de ce contenu, vous devriez utiliser les interpolations <code>{{ Mustache }}</code>.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">"msg"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-comment">&lt;!-- même chose que --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/syntax.html#Texte">Syntaxe de liaison de données - Interpolations</a></p>
</li>
</ul>
<h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><ul>
<li><p><strong>Attend comme valeur :</strong> <code>string</code></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Met à jour le contenu HTML (<code>innerHTML</code>) de l’élément. <strong>Notez que les contenus sont insérés en pur HTML - ils ne seront pas compilés en tant que templates Vue</strong>. Si vous vous retrouvez à vouloir composer des templates avec <code>v-html</code>, essayez de repenser la solution en utilisant des composants à la place.</p>
<p class="tip">Faire le rendu dynamique de code HTML arbitraire sur votre site web peut être très dangereux car cela peut mener facilement à des <a href="https://fr.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">attaques XSS</a>. Utilisez <code>v-html</code> uniquement avec du contenu de confiance et <strong>jamais</strong> avec du contenu fourni par les utilisateurs.</p>

<p class="tip">Dans les <a href="../guide/single-file-components.html">composants monofichiers</a>, les styles <code>scoped</code> ne seront pas appliqués aux contenus à l’intérieur de <code>v-html</code>, car ce HTML n’est pas gérer par le compilateur de template de Vue. Si vous voulez cibler le contenu <code>v-html</code> dans une CSS avec portée, vous devez utiliser à la place les <a href="https://vue-loader.vuejs.org/en/features/css-modules.html" target="_blank" rel="noopener">modules CSS</a> ou un élément <code>&lt;style&gt;</code> global supplémentaire avec une stratégie de portée manuelle comme avec BEM.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">"html"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/syntax.html#Interpetation-du-HTML">Syntaxe de liaison de données - Interpolations</a></p>
</li>
</ul>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><ul>
<li><p><strong>Attend comme valeur :</strong> <code>any</code></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Permute l’affichage de l’élément avec la propriété CSS <code>display</code> selon si la valeur de l’expression est « <a href="https://developer.mozilla.org/fr/docs/Glossaire/Truthy" target="_blank" rel="noopener">truthy</a> » ou non.</p>
<p>Cette directive déclenche des transitions quand sa condition change.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/conditional.html#v-show">Rendu conditionnel - v-show</a></p>
</li>
</ul>
<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><ul>
<li><p><strong>Attend comme valeur :</strong> <code>any</code></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Fait le rendu conditionnel de l’élément selon si la valeur de l’expression est <a href="https://developer.mozilla.org/fr/docs/Glossaire/Truthy" target="_blank" rel="noopener">truthy</a> ou non. L’élément et les directives / composants qu’il contient sont détruits et reconstruits durant la permutation. Si l’élément est un <code>&lt;template&gt;</code>, son contenu sera extrait en tant que bloc conditionnel.</p>
<p>Cette directive déclenche des transitions quand sa condition change.</p>
</li>
</ul>
<p class="tip">Quand utilisé avec v-if, v-for a une plus grande priorité par rapport à v-if. Voir le <a href="../guide/list.htmll#v-for-avec-v-if">guide sur le rendu de listes</a> pour plus de détails.</p>

<ul>
<li><strong>Voir aussi :</strong> <a href="../guide/conditional.html">Rendu conditionnel - v-if</a></li>
</ul>
<h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><ul>
<li><p><strong>N’attend aucune valeur</strong></p>
</li>
<li><p><strong>Restriction :</strong> l’élément précédent doit avoir une directive <code>v-if</code> ou <code>v-else-if</code>.</p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Dénote un bloc « else » pour <code>v-if</code> ou pour une chaine <code>v-if</code> / <code>v-else-if</code>.</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"Math.random() &gt; 0.5"</span>&gt;</span>
  Là vous me voyez
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>
  Là vous ne me voyez pas
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/conditional.html#v-else">Rendu conditionnel - v-else</a></p>
</li>
</ul>
<h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><blockquote>
<p>Nouveauté en 2.1.0+</p>
</blockquote>
<ul>
<li><p><strong>Attend comme valeur :</strong> <code>any</code></p>
</li>
<li><p><strong>Restriction :</strong> l’élément précédent doit avoir une directive <code>v-if</code> or <code>v-else-if</code>.</p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Dénote un bloc « else if » pour <code>v-if</code>. Peut être enchainé plusieurs fois.</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"type === 'A'"</span>&gt;</span>
  A
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type === 'B'"</span>&gt;</span>
  B
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type === 'C'"</span>&gt;</span>
  C
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>
  Ni A, ni B, ni C
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/conditional.html#v-else-if">Rendu conditionnel - v-else-if</a></p>
</li>
</ul>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><ul>
<li><p><strong>Attend comme valeur :</strong> <code>Array | Object | number | string | Iterable (depuis 2.6)</code></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Fait le rendu de l’élément ou du bloc template plusieurs fois selon les données sources. La valeur de la directive doit utiliser la syntaxe spéciale <code>alias in expression</code> pour fournir un alias à l’élément courant dans l’itération:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span>&gt;</span>
  &#123;&#123; item.text &#125;&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>Comme alternative, vous pouvez aussi spécifier un alias pour l’index courant dans l’itération (ou la clé si utilisée sur un <code>Object</code>):</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in items"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(val, key) in object"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(val, name, index) in object"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>Le comportement par défaut de <code>v-for</code> est qu’il essaiera de patcher les éléments actuellement en place sans les déplacer. Pour le forcer à réordonner les éléments, vous devez fournir un indice de tri avec l’attribut spécial <code>key</code> :</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span>
  &#123;&#123; item.text &#125;&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>En 2.6+, <code>v-for</code> peut également travailler sur des valeurs qui implémentent le <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Les_protocoles_iteration#The_iterable_protocol" target="_blank" rel="noopener">protocole Iterable</a>, incluant les natifs <code>Map</code> et <code>Set</code>. Cependant, il est à noter que Vue 2.x ne supporte pour le moment pas la réactivité sur les valeurs de <code>Map</code> et <code>Set</code> et ne pourra pas automatiquement détecter les changements.</p>
<p class="tip">Quand utilisé conjointement avec v-if, v-for a une plus grande priorité que v-if. Consultez le <a href="../guide/list.html#v-for-with-v-if">guide de rendu de listes</a> pour plus de détails.</p>

<p>L’usage détaillé pour <code>v-for</code> est expliqué dans la section du guide indiquée ci-dessous.</p>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="../guide/list.html">Rendu de liste</a></li>
<li><a href="../guide/list.html#key">key</a></li>
</ul>
</li>
</ul>
<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul>
<li><p><strong>Notation abrégée :</strong> <code>@</code></p>
</li>
<li><p><strong>Attend comme valeur :</strong> <code>Function | Inline Statement | Object</code></p>
</li>
<li><p><strong>Argument de la fonction de rappel (callback) :</strong> <code>event</code></p>
</li>
<li><p><strong>Modificateurs :</strong></p>
<ul>
<li><code>.stop</code> - appelle <code>event.stopPropagation()</code>.</li>
<li><code>.prevent</code> - appelle <code>event.preventDefault()</code>.</li>
<li><code>.capture</code> - ajoute l’écouteur d’évènement en mode capture.</li>
<li><code>.self</code> - déclenche le gestionnaire d’évènement uniquement si l’évènement provient de cet élément.</li>
<li><code>.{keyCode | keyAlias}</code> - déclenche le gestionnaire d’évènement uniquement pour certaines touches du clavier.</li>
<li><code>.native</code> - écoute un évènement natif sur l’élément racine d’un composant.</li>
<li><code>.once</code> - déclenche le gestionnaire d’évènement une seule fois maximum.</li>
<li><code>.left</code> - (2.2.0+) déclenche le gestionnaire d’évènement uniquement pour les évènements du bouton gauche de la souris.</li>
<li><code>.right</code> - (2.2.0+) déclenche le gestionnaire d’évènement uniquement pour les évènements du bouton droit de la souris.</li>
<li><code>.middle</code> - (2.2.0+) déclenche le gestionnaire d’évènement uniquement pour les évènements du bouton du milieu de la souris.</li>
<li><code>.passive</code> - (2.3.0+) attache un évènement du DOM avec <code>{ passive: true }</code>.</li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Attache un écouteur d’évènement à l’élément. Le type d’évènement écouté est indiqué comme argument. L’expression peut être soit un nom de méthode, soit une ligne d’instruction, ou simplement omise si des modificateurs sont présents.</p>
<p>Quand utilisé sur un élément standard, il écoute uniquement les <a href="https://developer.mozilla.org/fr/docs/Web/Events" target="_blank" rel="noopener"><strong>évènements natifs du DOM</strong></a>. Quand utilisé sur un élément personnalisé de composant, il écoute également les <strong>évènements personnalisés</strong> émis depuis ce composant enfant.</p>
<p>Lorsque des évènements natifs du DOM sont écoutés, la méthode reçoit l’évènement natif comme unique argument. Si la valeur de la directive est une ligne d’instruction, l’instruction a accès à la propriété spéciale <code>$event</code> : <code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>.</p>
<p>À partir de la 2.4.0+, <code>v-on</code> supporte aussi la liaison à un objet de paires évènement/écouteur sans argument. Notez que lorsque vous utilisez la syntaxe objet, elle ne supporte aucun modificateur.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- nom de méthode --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"faireCeci"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- évènement dynamique (2.6.0+) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:</span>[<span class="hljs-attr">event</span>]=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- ligne d'instruction --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"faireCela('hello', $event)"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- notation abrégée --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"faireCeci"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- notation abrégée d'un évènement dynamique (2.6.0+) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @[<span class="hljs-attr">event</span>]=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- stoppe la propagation --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">"faireCeci"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- empêche le comportement par défaut --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">"faireCeci"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- empêche le comportement par défaut sans expression --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-comment">&lt;!-- enchainer les modificateurs --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop.prevent</span>=<span class="hljs-string">"faireCeci"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- modificateur de touche avec un keyAlias --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">"onEnter"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- modificateur de touche avec un keyCode --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.13</span>=<span class="hljs-string">"onEnter"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- l'évènement click sera déclenché une seule fois maximum --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.once</span>=<span class="hljs-string">"faireCeci"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- syntaxe objet (2.4.0+) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">"&#123; mousedown: faireCeci, mouseup: faireCela &#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<p>Écouter des évènements personnalisés sur un composant enfant (le gestionnaire est appelé quand <code>mon-evenement</code> est émis depuis l’enfant):</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">mon-composant</span> @<span class="hljs-attr">mon-evenement</span>=<span class="hljs-string">"faireCeci"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mon-composant</span>&gt;</span>

<span class="hljs-comment">&lt;!-- ligne d'instruction --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mon-composant</span> @<span class="hljs-attr">mon-evenement</span>=<span class="hljs-string">"faireCeci(123, $event)"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mon-composant</span>&gt;</span>

<span class="hljs-comment">&lt;!-- évènement natif sur le composant --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mon-composant</span> @<span class="hljs-attr">click.native</span>=<span class="hljs-string">"onClick"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mon-composant</span>&gt;</span></code></pre>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="../guide/events.html">Gestion des évènements</a></li>
<li><a href="../guide/components.html#Evenements-personnalises">Composants - Évènements personnalisés</a></li>
</ul>
</li>
</ul>
<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul>
<li><p><strong>Notation abrégée :</strong> <code>:</code></p>
</li>
<li><p><strong>Attend comme valeur :</strong> <code>any (avec argument) | Object (sans argument)</code></p>
</li>
<li><p><strong>Argument :</strong> <code>attrOuProp (optionnel)</code></p>
</li>
<li><p><strong>Modificateurs :</strong></p>
<ul>
<li><code>.prop</code> - Associe une propriété du DOM plutôt qu’un attribut. (<a href="https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028" target="_blank" rel="noopener">Quelle différence ?</a>). Si le tag est un composant, alors <code>.prop</code> assignera la propriété sur l’élément <code>$el</code> du composant.</li>
<li><code>.camel</code> - (2.1.0+) transforme un nom d’attribut en kebab-case en sa version camelCase.</li>
<li><code>.sync</code> - (2.3.0+) du sucre syntaxique pour ajouter un gestionnaire <code>v-on</code> qui met à jour la valeur liée.</li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Lie dynamiquement un ou plusieurs attributs HTML ou props de composants à une expression.</p>
<p>Quand utilisér pour lier un attribut <code>class</code> ou <code>style</code>, la directive supporte des types additionnels de valeur tels que <code>Array</code> ou <code>Object</code>. Consultez la section du guide en lien ci-dessous pour plus de détails.</p>
<p>Quand utilisée pour lier à une prop de composant, la prop doit être bien déclarée dans le composant enfant.</p>
<p>Utilisée sans argument, la directive peut lier un objet contenant des paires clé-valeur d’attributs. Notez que dans ce mode, <code>class</code> et <code>style</code> ne supportent pas les <code>Array</code> ou <code>Object</code>.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- lie un attribut --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">"imageSrc"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- nom d'attribut dynamique (2.6.0+) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">key</span>]=<span class="hljs-string">"value"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- notation abrégée --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">"imageSrc"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- notation abrégée d'un nom d'attribut dynamique (2.6.0+) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">key</span>]=<span class="hljs-string">"value"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- avec de la concaténation de chaines de caractères --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">"'/path/to/images/' + fileName"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- liaison de classes --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"&#123; red: isRed &#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"[classA, classB]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"[classA, &#123; classB: isB, classC: isC &#125;]"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- liaison de styles --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"&#123; fontSize: size + 'px' &#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"[styleObjectA, styleObjectB]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- lie un objet d'attributs --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"&#123; id: uneProp, 'autre-attr': uneAutreProp &#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- lie un attribut du DOM avec le modificateur prop --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:text-content.prop</span>=<span class="hljs-string">"text"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- liaison de prop. "prop" doit être déclaré dans mon-composant. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mon-composant</span> <span class="hljs-attr">:prop</span>=<span class="hljs-string">"uneValeur"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mon-composant</span>&gt;</span>

<span class="hljs-comment">&lt;!-- transmet les props parentes à un composant enfant --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">composant-enfant</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"$props"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">composant-enfant</span>&gt;</span>

<span class="hljs-comment">&lt;!-- XLink --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:xlink:special</span>=<span class="hljs-string">"foo"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre>
<p>Le modificateur <code>.camel</code> permet de réécrire en camelCase un nom d’attribut de <code>v-bind</code> si vous déclarez vos templates dans le DOM, p. ex. l’attribut SVG <code>viewBox</code> :</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">:view-box.camel</span>=<span class="hljs-string">"viewBox"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre>
<p><code>.camel</code> n’est pas nécessaire si vous utilisez des templates en chaine de caractères ou si vous les compilez avec <code>vue-loader</code>/<code>vueify</code>.</p>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="../guide/class-and-style.html">Liaisons de classe et de style</a></li>
<li><a href="../guide/components.html#Props">Composants - Props de composant</a></li>
<li><a href="../guide/components.html#Modificateur-sync">Composants - Modificateur <code>.sync</code></a></li>
</ul>
</li>
</ul>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul>
<li><p><strong>Attend comme valeur :</strong> variable selon les éléments des champs de formulaire ou les valeurs en sortie de composants</p>
</li>
<li><p><strong>Limité à :</strong></p>
<ul>
<li><code>&lt;input&gt;</code></li>
<li><code>&lt;select&gt;</code></li>
<li><code>&lt;textarea&gt;</code></li>
<li>composants</li>
</ul>
</li>
<li><p><strong>Modificateurs :</strong></p>
<ul>
<li><a href="../guide/forms.html#lazy"><code>.lazy</code></a> - écoute les évènements <code>change</code> au lieu de <code>input</code></li>
<li><a href="../guide/forms.html#number"><code>.number</code></a> - convertit les chaines de caractères d’entrée en nombres</li>
<li><a href="../guide/forms.html#trim"><code>.trim</code></a> - retire les blancs autour des chaines de caractères en entrée</li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Crée une liaison bidirectionnelle sur un élément de saisie d’un formulaire ou sur un composant. Pour une utilisation détaillée et d’autres notes, consultez la section du guide en lien ci-dessous.</p>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="../guide/forms.html">Liaisons sur les champs de formulaire</a></li>
<li><a href="../guide/components.html#Composants-de-champ-de-formulaire-utilisant-les-evenements-personnalises">Composants - Composants de champ de formulaire utilisant les évènements personnalisés</a></li>
</ul>
</li>
</ul>
<h3 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h3><ul>
<li><p><strong>Notation abrégée :</strong> <code>#</code></p>
</li>
<li><p><strong>Attend comme valeur :</strong> Une expression JavaScript qui est valide a une position d’argument dans une fonction (supporte la décomposition dans les <a href="../guide/components-slots.html#Décomposition-de-props-de-slot">environnements la supportant</a>). Optionnel - seulement nécessaire si le passage des props est attendu par le slot.</p>
</li>
<li><p><strong>Argument :</strong> nom du slot (optionel, <code>default</code> par défaut)</p>
</li>
<li><p><strong>Limité à :</strong></p>
<ul>
<li><code>&lt;template&gt;</code></li>
<li><a href="../guide/components-slots.html#Syntaxe-abrégée-pour-les-slots-par-défault-uniques">composants</a> (pour les slot par défaut avec props)</li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Indiquez les slots nommés ou slots qui attendent de recevoir des props.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Slots nommés --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span>
    Contenu d'en-tête
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  Contenu par défaut de slot

  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span>
    Contenu de pied de page
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Slot nommé recevant des props --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">infinite-scroll</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:item</span>=<span class="hljs-string">"slotProps"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>
      &#123;&#123; slotProps.item.text &#125;&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">infinite-scroll</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Slot par défaut recevant des props, avec décomposition --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mouse-position</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"&#123; x, y &#125;"</span>&gt;</span>
  Mouse position: &#123;&#123; x &#125;&#125;, &#123;&#123; y &#125;&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">mouse-position</span>&gt;</span></code></pre>
<p>Pour plus de détails, voir les liens ci-dessous.</p>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="../guide/components-slots.html">Composants - Slots</a></li>
<li><a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md" target="_blank" rel="noopener">RFC-0001</a></li>
</ul>
</li>
</ul>
<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><ul>
<li><p><strong>N’attend aucune valeur</strong></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Omet la compilation pour cet élément et tous ses enfants. Vous pouvez utiliser ceci pour afficher à l’utilisateur des expressions <code></code>. Utilisé sur un grand nombre de nœuds sans directives, cela peut aussi accélérer la compilation.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-pre</span>&gt;</span>&#123;&#123; ceci ne sera pas compilé &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre>
</li>
</ul>
<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><ul>
<li><p><strong>N’attend aucune valeur</strong></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Cette directive restera sur l’élément jusqu’à ce que l’instance de Vue associée ait fini sa compilation. Combiné avec des règles CSS telles que <code>[v-cloak] { display: none }</code>, cette directive peut être utilisée pour cacher des liaisons moustaches encore non compilées jusqu’à ce que l’instance de Vue soit prête.</p>
</li>
<li><p><strong>Exemple :</strong></p>
<pre><code class="hljs css"><span class="hljs-selector-attr">[v-cloak]</span> &#123;
  <span class="hljs-attribute">display</span>: none;
&#125;</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-cloak</span>&gt;</span>
  &#123;&#123; message &#125;&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>L’élément <code>&lt;div&gt;</code> ne sera pas visible jusqu’à ce que la compilation soit terminée.</p>
</li>
</ul>
<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><ul>
<li><p><strong>N’attend aucune valeur</strong></p>
</li>
<li><p><strong>Détails :</strong></p>
<p>Fait le rendu de l’élément ou du composant qu’<strong>une seule fois</strong> seulement. Lors des nouveaux rendus par la suite, l’élément/composant et tous ses enfants seront traités comme du contenu statique et ignorés. Cela peut être utilisé pour optimiser les performances à la mise à jour d’un composant.</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- sur un seul élément --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-once</span>&gt;</span>Ceci ne changera jamais : &#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-comment">&lt;!-- l'élément a des enfants --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-once</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>commentaire<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-comment">&lt;!-- composant --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mon-composant</span> <span class="hljs-attr">v-once</span> <span class="hljs-attr">:commentaire</span>=<span class="hljs-string">"msg"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mon-composant</span>&gt;</span>
<span class="hljs-comment">&lt;!-- directive `v-for` --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"i in liste"</span> <span class="hljs-attr">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="../guide/syntax.html#Texte">Syntaxe de liaison de données - Interpolations</a></li>
<li><a href="../guide/components.html#Cheap-Static-Components-with-v-once">Composants - Composants statiques peu couteux avec <code>v-once</code></a></li>
</ul>
</li>
</ul>
<h2 id="Attributs-speciaux"><a href="#Attributs-speciaux" class="headerlink" title="Attributs spéciaux"></a>Attributs spéciaux</h2><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><ul>
<li><p><strong>Attend comme valeur :</strong> <code>number | string</code></p>
<p>L’attribut spécial <code>key</code> est principalement utilisé comme marqueur pour l’algorithme de DOM virtuel de Vue afin d’identifier les <em>VNodes</em> lors du différentiel entre la nouvelle liste des nœuds et la liste précédente. Sans clés, Vue utilise un algorithme qui minimise le déplacement de nœuds et essaie de patcher/réutiliser le plus possible les éléments présents du même type. Avec des clés, cela réordonnera les éléments en se basant sur le nouvel ordre de clés, et les éléments avec des clés qui ne sont plus présentes seront toujours supprimés/détruits.</p>
<p>Les enfants d’un même parent commun doivent avoir des <strong>clés uniques</strong>. Des clés en doublons causeront des erreurs de rendu.</p>
<p>Le cas d’utilisation le plus classique est la combinaison avec <code>v-for</code>:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre>
<p>Il peut aussi être utilisé pour forcer le remplacement d’un élément/composant au lieu de le réutiliser. Cela peut être utile lorsque vous voulez :</p>
<ul>
<li>Déclencher correctement les hooks de cycle de vie d’un composant</li>
<li>Déclencher des transitions</li>
</ul>
<p>Par exemple :</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"texte"</span>&gt;</span>&#123;&#123; texte &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span></code></pre>
<p>Quand <code>texte</code> change, le <code>&lt;span&gt;</code> sera toujours remplacé plutôt que d’être patché, afin qu’une transition soit déclenchée.</p>
</li>
</ul>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul>
<li><p><strong>Attend comme valeur :</strong> <code>string</code></p>
<p><code>ref</code> est utilisé pour inscrire une référence à un élément ou à un composant enfant. La référence sera inscrite sous l’objet <code>$refs</code> du composant parent. Lorsqu’utilisée sur un élément du DOM, la référence sera cet élément; lorsqu’utilisée sur un composant enfant, la référence sera l’instance du composant :</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- vm.$refs.p sera le nœud du DOM --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"p"</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-comment">&lt;!-- vm.$refs.enfant sera l'instance du composant enfant --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">comp-enfant</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"enfant"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">comp-enfant</span>&gt;</span></code></pre>
<p>Quand utilisé sur des éléments/composants avec <code>v-for</code>, la référence inscrite sera un <code>Array</code> contenant les nœuds du DOM ou les instances de composant.</p>
<p>Une note importante à propos du timing de l’inscription de la référence: étant donné que les refs elles-mêmes résultent de la fonction de rendu, vous ne pouvez pas y accéder au rendu initial - elles n’existent pas encore ! <code>$refs</code> est également non réactif, c’est pourquoi vous ne devriez pas essayer de les utiliser dans des templates pour de la liaison de données.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/components.html#Les-refs-des-composants-enfants">Les refs des composants enfants</a></p>
</li>
</ul>
<h3 id="is"><a href="#is" class="headerlink" title="is"></a>is</h3><ul>
<li><p><strong>Attend comme valeur :</strong> <code>string | Object (un objet d&#39;options de composant)</code></p>
<p>Utilisé pour les <a href="../guide/components.html#Composants-dynamiques">composants dynamiques</a> et pour contourner les <a href="../guide/components.html#Limitations-de-l’analyse-d’un-template-a-partir-du-DOM">limitations des templates dans le DOM</a>.</p>
<p>Par exemple :</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- le composant change quand la vue actuelle change --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">v-bind:is</span>=<span class="hljs-string">"vueActuelle"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>

<span class="hljs-comment">&lt;!-- nécessaire car `&lt;ma-ligne&gt;` sera invalide à l'intérieur --&gt;</span>
<span class="hljs-comment">&lt;!-- d'un élément `&lt;table&gt;` et donc sera écarté --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">is</span>=<span class="hljs-string">"ma-ligne"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre>
<p>Pour un usage détaillé, suivez les liens dans la description ci-dessus.</p>
</li>
<li><p><strong>Voir aussi :</strong></p>
<ul>
<li><a href="../guide/components.html#Composants-dynamiques">Composants dynamiques</a></li>
<li><a href="../guide/components.html#Limitations-de-l’analyse-d’un-template-a-partir-du-DOM">Limitations de l’analyse d’un template à partir du DOM</a></li>
</ul>
</li>
</ul>
<h3 id="slot-deprecie"><a href="#slot-deprecie" class="headerlink" title="slot déprécié"></a>slot <sup style="color:#c92222">déprécié</sup></h3><p><strong>Préférez <a href="#v-slot">v-slot</a> en 2.6.0+.</strong></p>
<ul>
<li><p><strong>Attend comme valeur :</strong> <code>string</code></p>
<p>Utilisez sur un contenu inséré dans un composant enfant pour indiquer à quel slot nommé le contenu appartient.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/components.html#Slots-nommés-avec-slot">Slots nommés avec <code>slot</code></a></p>
</li>
</ul>
<h3 id="slot-scope-deprecie"><a href="#slot-scope-deprecie" class="headerlink" title="slot-scope déprécié"></a>slot-scope <sup style="color:#c92222">déprécié</sup></h3><p><strong>Prefer <a href="#v-slot">v-slot</a> in 2.6.0+.</strong></p>
<ul>
<li><p><strong>Attend comme valeur :</strong> <code>function argument expression</code></p>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Utilisé pour indiquer qu’un élément ou un composant a un slot avec portée. La valeur de l’attribut doit être une expression JavaScript valide qui apparaît à la position d’un argument dans la déclaration d’une fonction. Cela signifie que dans les environnements qui la supportent, vous pouvez utiliser une expression de destructuration dans l’expression. Remplace <a href="#scope-replaced"><code>scope</code></a> dans la 2.5.0+.</p>
<p>Cet attribut ne supporte pas les liaisons dynamiques.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/components.html#Slots-avec-portee">Slots avec portée with <code>slot-scope</code></a></p>
</li>
</ul>
<h3 id="scope-supprime"><a href="#scope-supprime" class="headerlink" title="scope supprimé"></a>scope <sup style="color:#c92222">supprimé</sup></h3><p><strong>Remplacé par <a href="#slot-scope">slot-scope</a> dans la 2.5.0+. Préférez <a href="#v-slot">v-slot</a> dans la 2.6.0+.</strong></p>
<p>Utilisé pour indiquer un élément <code>&lt;template&gt;</code> en tant que slot avec portée.</p>
<ul>
<li><p><strong>utilisation :</strong></p>
<p>Identique à <a href="#slot-scope"><code>slot-scope</code></a> à l’exception que <code>scope</code> peut uniquement être utilisé sur des éléments <code>&lt;template&gt;</code> elements.</p>
</li>
</ul>
<h2 id="Composants-integres-par-defaut"><a href="#Composants-integres-par-defaut" class="headerlink" title="Composants intégrés par défaut"></a>Composants intégrés par défaut</h2><h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li>
<li><code>inline-template</code> - booléen</li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Un « métacomposant » pour le rendu de composants dynamiques. Le composant réel obtenu est déterminé par la prop <code>is</code> :</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- un composant dynamique contrôlé par --&gt;</span>
<span class="hljs-comment">&lt;!-- la propriété `idComposant` de l'instance de vue --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"idComposant"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>

<span class="hljs-comment">&lt;!-- peut aussi faire le rendu de composants inscrits globalement ou passés comme prop --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"$options.components.enfant"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/components.html#Composants-dynamiques">Composants dynamiques</a></p>
</li>
</ul>
<h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>name</code> - string, utilisé pour générer automatiquement des noms de classes CSS pour les transitions. p. ex. <code>name: &#39;fade&#39;</code> donnera <code>.fade-enter</code>, <code>.fade-enter-active</code>, etc. Valeur par défaut : <code>&quot;v&quot;</code>.</li>
<li><code>appear</code> - booléen, indique si la transition doit être appliquée ou non au rendu initial. Valeur par défaut: <code>false</code>.</li>
<li><code>css</code> - booléen, indique si les classes CSS de transition doivent être appliquées ou non. Valeur par défaut: <code>true</code>. Si assigné à <code>false</code>, seuls les hooks JavaScript inscrits via les évènements du composant seront déclenchés.</li>
<li><code>type</code> - string, spécifie le type d’évènement de transition à attendre pour déterminer le timing de fin de transition. Les valeurs disponibles sont <code>&quot;transition&quot;</code> and <code>&quot;animation&quot;</code>. Par défaut, il détectera automatiquement le type ayant la durée la plus longue.</li>
<li><code>mode</code> - string, contrôle la séquence de timing des transitions entrantes/sortantes. Les modes disponibles sont <code>&quot;out-in&quot;</code> et <code>&quot;in-out&quot;</code>; par défaut en simultané.</li>
<li><code>duration</code> - number | { <code>enter</code>: number, <code>leave</code>: number }, spécifie la durée de la transition. Par défaut, Vue attend le premier évènement <code>transitionend</code> ou <code>animationend</code> de l’élément de transition racine.</li>
<li><code>enter-class</code> - string</li>
<li><code>leave-class</code> - string</li>
<li><code>appear-class</code> - string</li>
<li><code>enter-to-class</code> - string</li>
<li><code>leave-to-class</code> - string</li>
<li><code>appear-to-class</code> - string</li>
<li><code>enter-active-class</code> - string</li>
<li><code>leave-active-class</code> - string</li>
<li><code>appear-active-class</code> - string</li>
</ul>
</li>
<li><p><strong>Events:</strong></p>
<ul>
<li><code>before-enter</code></li>
<li><code>before-leave</code></li>
<li><code>before-appear</code></li>
<li><code>enter</code></li>
<li><code>leave</code></li>
<li><code>appear</code></li>
<li><code>after-enter</code></li>
<li><code>after-leave</code></li>
<li><code>after-appear</code></li>
<li><code>enter-cancelled</code></li>
<li><code>leave-cancelled</code> (<code>v-show</code> uniquement)</li>
<li><code>appear-cancelled</code></li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p><code>&lt;transition&gt;</code> sert d’effets de transition pour un  <strong>unique</strong> élément / composant. Le rendu de <code>&lt;transition&gt;</code> ne donne pas un élément supplémentaire dans le DOM, et n’apparait pas non plus dans la hiérarchie du composant inspecté. Il applique simplement le comportement de transition au contenu imbriqué à l’intérieur.</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- élément simple --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"ok"</span>&gt;</span>contenu permuté<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span>

<span class="hljs-comment">&lt;!-- composant dynamique --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fade"</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"out-in"</span> <span class="hljs-attr">appear</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span>

<span class="hljs-comment">&lt;!-- hooks d'évènement --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transition-demo"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> @<span class="hljs-attr">after-enter</span>=<span class="hljs-string">"transitionComplete"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"ok"</span>&gt;</span>contenu permuté<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;
  ...
  methods: &#123;
    <span class="hljs-attr">transitionComplete</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>&#123;
      <span class="hljs-comment">// pour l'élément du DOM 'el' passé en argument, faire quelque-chose...</span>
    &#125;
  &#125;
  ...
&#125;).$mount(<span class="hljs-string">'#transition-demo'</span>)</code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/transitions.html">Transitions : entrantes, sortantes et de listes</a></p>
</li>
</ul>
<h3 id="transition-group"><a href="#transition-group" class="headerlink" title="transition-group"></a>transition-group</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>tag</code> - string, par défaut <code>span</code>.</li>
<li><code>move-class</code> - surcharge la classe CSS appliquée durant le mouvement de transition.</li>
<li>expose les mêmes props que <code>&lt;transition&gt;</code> à l’exception de <code>mode</code>.</li>
</ul>
</li>
<li><p><strong>Évènements:</strong></p>
<ul>
<li>expose les mêmes évènements que <code>&lt;transition&gt;</code>.</li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p><code>&lt;transition-group&gt;</code> sert d’effets de transition pour de <strong>multiples</strong> éléments / composants. Le rendu de <code>&lt;transition-group&gt;</code> donne un nouvel élément dans le DOM. Par défaut, il s’agit d’un <code>&lt;span&gt;</code>, mais vous pouvez configurer le type d’élément en sortie via l’attribut <code>tag</code>.</p>
<p>Notez que chaque enfant dans un <code>&lt;transition-group&gt;</code> doit avoir une <strong>clé unique</strong> pour que les animations fonctionnent correctement.</p>
<p><code>&lt;transition-group&gt;</code> supporte les déplacements de transition via les transformations CSS. Quand la position à l’écran d’un élément enfant a changé après une mise à jour, une classe CSS de déplacement (auto générée à partir de l’attribut <code>name</code> ou configurée via l’attribut <code>move-class</code>) est appliquée. Si la propriété CSS <code>transform</code> permet les transitions quand la classe de déplacement est appliquée, l’élément sera animé de façon fluide jusqu’à sa destination en utilisant la <a href="https://aerotwist.com/blog/flip-your-animations/" target="_blank" rel="noopener">technique FLIP</a>.</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">"ul"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"slide"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span>
    &#123;&#123; item.text &#125;&#125;
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span></code></pre>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/transitions.html">Transition : entrantes, sortantes et de listes</a></p>
</li>
</ul>
<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>include</code> - string ou RegExp. Seuls les composants correspondants seront mis en cache.</li>
<li><code>exclude</code> - string ou RegExp. Les composants correspondants ne seront pas mis en cache.</li>
<li><code>max</code> - number. Le nombre maximum d’instances de composant à mettre en cache.</li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p>Quand il entoure un composant dynamique, <code>&lt;keep-alive&gt;</code> met en cache les instances de composant inactives sans les détruire. Tout comme <code>&lt;transition&gt;</code>, <code>&lt;keep-alive&gt;</code> est un composant abstrait : le rendu ne donne pas d’élément supplémentaire dans le DOM, et il n’apparait pas dans la chaine de composants du parent.</p>
<p>Lorsqu’un composant est permuté à l’intérieur de <code>&lt;keep-alive&gt;</code>, ses hooks de cycle de vie <code>activated</code> et <code>deactivated</code> seront appelés en conséquence.</p>
<blockquote>
<p>À partir de la 2.2.0+, <code>activated</code> et <code>deactivated</code> se déclencheront pour tous les composants imbriqués dans une arborescence <code>&lt;keep-alive&gt;</code>.</p>
</blockquote>
<p>Principalement utilisé pour préserver l’état du composant ou éviter un nouveau rendu.</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- basique --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>

<span class="hljs-comment">&lt;!-- de multiples enfants conditionnels --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">comp-a</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"a &gt; 1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">comp-a</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">comp-b</span> <span class="hljs-attr">v-else</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">comp-b</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>

<span class="hljs-comment">&lt;!-- utilisé avec `&lt;transition&gt;` --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span></code></pre>
<p>Notez que <code>&lt;keep-alive&gt;</code> est conçu pour le cas où il a un seul composant enfant direct qui est permuté. Il ne fonctionne pas si vous avez <code>v-for</code> à l’intérieur. Quand il y a de multiples enfants conditionnels, comme ci-dessus, <code>&lt;keep-alive&gt;</code> requiert qu’un seul enfant soit visible à la fois.</p>
</li>
<li><p><strong><code>include</code> et <code>exclude</code></strong></p>
<blockquote>
<p>Nouveauté de la 2.1.0+</p>
</blockquote>
<p>Les props <code>include</code> et <code>exclude</code> définissent les conditions de mise en cache des composants. Les deux props peuvent être soit une liste délimitée par des virgules, soit une expression régulière, soit une Array :</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- liste délimitée par des virgules --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">"a,b"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>

<span class="hljs-comment">&lt;!-- expression régulière (utiliser `v-bind`) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">"/a|b/"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Array (utiliser `v-bind`) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">"['a', 'b']"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></code></pre>
<p>La correspondance est d’abord faite avec l’option <code>name</code> propre au composant, puis avec son nom d’inscription locale (la clé dans l’option <code>components</code> du parent) si l’option <code>name</code> n’est pas disponible. Les composants anonymes ne peuvent pas être mis en correspondance.</p>
</li>
<li><p><strong><code>max</code></strong></p>
<blockquote>
<p>Nouveauté de la 2.5.0+</p>
</blockquote>
<p>Le nombre maximum d’instances de composant à mettre en cache. Une fois que ce nombre est atteind, l’instance du composant en cache qui a été le plus récemment accédé est détruit avant que la nouvelle instance soit créée.</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:max</span>=<span class="hljs-string">"10"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></code></pre>
<p class="tip"><code>&lt;keep-alive&gt;</code> ne fonctionne pas avec les composants fonctionnels puisqu’ils n’ont pas d’instances à mettre en cache.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/components.html#keep-alive">Composants dynamiques - keep-alive</a></p>
</li>
</ul>
<h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>name</code> - string, utilisé pour nommer le slot.</li>
</ul>
</li>
<li><p><strong>Utilisation :</strong></p>
<p><code>&lt;slot&gt;</code> sert d’emplacement de distribution de contenu dans les templates de composant. L’élement <code>&lt;slot&gt;</code> lui-même sera remplacé par le contenu.</p>
<p>Pour un usage détaillé, consultez la section du guide en lien ci-dessous.</p>
</li>
<li><p><strong>Voir aussi :</strong> <a href="../guide/components.html#Distribution-de-contenu-avec-des-slots">Distribution de contenu avec des slots</a></p>
</li>
</ul>
<h2 id="Interface-VNode"><a href="#Interface-VNode" class="headerlink" title="Interface VNode"></a>Interface VNode</h2><ul>
<li>Veuillez vous référer à la <a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js" target="_blank" rel="noopener">déclaration de classe VNode</a>.</li>
</ul>
<h2 id="Rendu-cote-serveur"><a href="#Rendu-cote-serveur" class="headerlink" title="Rendu côté serveur"></a>Rendu côté serveur</h2><ul>
<li>Veuillez vous référer à la <a href="https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer" target="_blank" rel="noopener">documentation du package vue-server-renderer</a>.</li>
</ul>

  
  
  <div class="footer">
      <script src="//m.servedby-buysellads.com/monetization.js" type="text/javascript"></script>
<div class="bsa-cpc"></div>
<script>
  (function(){
    if(typeof _bsa !== 'undefined' && _bsa) {
    _bsa.init('default', 'CKYD62QM', 'placement:vuejsorg', {
      target: '.bsa-cpc',
      align: 'horizontal',
      disable_css: 'true'
    });
      }
  })();
</script>

    Une erreur dans cette page ? Envie de contribuer à la traduction ?
    <a href="https://github.com/vuejs-fr/vuejs.org/blob/master/src/v2/api/index.md" target="_blank">
      Éditez cette page sur GitHub !
    </a>
  </div>
</div>

        
      </div>
      <script src="/js/smooth-scroll.min.js"></script>
    

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="/js/css.escape.js"></script>
    <script src="/js/common.js"></script>

    <!-- search -->
    <link href="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/css/search.css">
    <script src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <script>
    [
      '#search-query-nav',
      '#search-query-sidebar',
      '#search-query-menu'
    ].forEach(function (selector) {
      if (!document.querySelector(selector)) return
      // search index defaults to v2
      var match = window.location.pathname.match(/^\/(v\d+)/)
      var version = match ? match[1] : 'v2'
      docsearch({
      appId: 'BH4D9OD16A',
      apiKey: '85cc3221c9f23bfbaa4e3913dd7625ea',
      indexName: 'vuejs',
      inputSelector: selector,
      algoliaOptions: { facetFilters: ["version:" + version] },
      autocompleteOptions: { hint: false, appendTo: 'body'}
      })
    })
    </script>

    <!-- fastclick -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
